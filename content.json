[{"title":"java异常处理学习","date":"2017-11-20T05:56:47.000Z","path":"2017/11/20/java-exception-handling/","text":"在开发 程序的过程中，我们可能经常会和异常打交道，那么出现异常时我们应该怎么处理呢，我们一起来学习一下。 基本异常处理java提供了在程序中处理某些特定类型条件的方法，能够把程序或方法划分为正常情况或异常情况两部分。异常是一个对象，创建这个对象的过程，也被称为抛出异常。实例如下：12345678910public void LearnException(int i) &#123; try &#123; if (i &lt; 1) &#123; throw new ArithmeticException(\"请传入大于0的整数\"); &#125; int result = 100/i; &#125; catch (ArithmeticException e) &#123; System.out.println(\"出现异常了\"); &#125;&#125; 从上面这个例子我们可以看出，java处理异常的基本方式有try-throw-catch三元组成。 try语句块。try是尝试的意思，try语句块中的代码通常是你不能百分之百的确定，但是你想进行一次尝试。它的基本轮廓如下； 12345 try &#123; Code_To_Try Possibly_Throw_An_Exception More_Code&#125; throw语句块。上述的例子，也等同与如下代码： 12ArithmeticException arithmeticException = new ArithmeticException(\"请传入大于0的整数\");throw arithmeticException; 实际上，就是new一个异常对象，然后抛出的过程。当异常被抛出时，该块中的代码停止执行，跳出try语句块。 catch语句块。其格式如下： 123 catch (ArithmeticException e) &#123; Handling_Exception&#125; 标识符e就像一个参数，接收刚才抛出的异常，所以e的类型必须等同于抛出的异常类型，否则不能捕获异常。 定义自己的异常类 我们也可以自己定义一个异常类，但必须继承已经定义好的异常类的。代码如下： 12345678 public class DivideByZeroException extends Exception &#123; public DivideByZeroException() &#123; super(\"请传入大于0的整数\"); // 调用基类Exception的构造器 &#125; public DivideByZeroException(String message) &#123; super(message); // 调用基类Exception的构造器 &#125;&#125; 调用方法如下： 12345678 try &#123; if (i &lt; 1) &#123; throw new DivideByZeroException(); &#125; int result = 100/i;&#125; catch (DivideByZeroException e) &#123; System.out.println(\"出现异常了\");&#125; 当我们自己定义异常类时，我们需要注意一下三点： 如果你没有更合理的理由使用其他的异常类作为基类，那么就使用Exception作为基类。 你定义的异常类至少定义了两个构造器——一个默认构造器，一个拥有String参数的构造器。通常情况下，自己定义的异常类都要保留getMessage方法。 在每一个构造器中，你应该以对基类构造器的调用作为开始，使用super调用。 如果你在写代码时就已经清楚可能会抛出异常，那么最后自己定义一个异常，这样当出现异常时，我们就更容易区分你的异常和预定义类中的异常。 声明异常 有时候我们需要延迟处理异常。比如你有一个代码块可能会抛出异常，但你并不想在这个代码块中捕获异常。因为可能某些程序调用该方法抛出异常后应该简单的终止程序，而另一程序调用该方法抛出异常后要做一些其他的处理。所以，当出现类似这种情况时，我们需要在在方法头部声明异常。代码如下： 12345public void LearnException(int i) throws DivideByZeroException &#123; Code_To_Try throw new DivideByZeroException(); More_Code&#125; 如果方法抛出了异常，方法调用立即结束。在方法的首部声明异常的一个好处是，我们可以清楚的区分可能有异常的方法和没有异常的方法，易于阅读。 关键字throw用于抛出异常，throws用于声明异常。 异常的种类所有的java异常可以分为两类：可控异常，不可控异常。上述的异常属于可控异常，即：异常必须在catch快中捕获或者在方法的首部声明。不可控异常也称为运行时异常（RuntimeException），当出现此类异常时，通常我们应该修正自己的代码，而不是添加catch语句块。 多重捕获和finally 多重捕获。一个try语句块可以抛出任意数量的异常，这些异常可以是不同的类型，因为一个catch语句块只能捕获一种异常，所以一个try语句块可以使用多个catch语句块。 finally关键字 。无论代码是否发生异常，finally中的代码块总会被执行。代码如下：123456789try &#123; // do sth&#125; catch (DivideByZeroException e1) &#123; // do sth&#125; catch (IOException) &#123; // do sth&#125; finally &#123; // do sth&#125; 总结 我们应该在什么时候抛出异常呢？在 When to throw an exception? 中，推荐：当发现当前代码块的基本假设是错误时，应该抛出异常。 对于所有的异常都捕获Exception是否可行？可行但是不推荐。最好catch更为精确的异常。 在catch语句块中使用e.printStackTrace()是一个好的习惯么？并不推荐使用这种方法，很多情况下，并不能正确的提示代码出错的位置和相关信息。最好使用在控制台打印的方法。 error—错误 ： 是指程序无法处理的错误.比如内存溢出、端口占用、断言错误等。 参考文献： 《Java程序设计与问题解决》 Java 异常处理 When to throw an exception? Why is exception.printStackTrace() considered bad practice?","tags":[{"name":"exception","slug":"exception","permalink":"https://chuhang123.github.io/tags/exception/"},{"name":"throw","slug":"throw","permalink":"https://chuhang123.github.io/tags/throw/"},{"name":"catch","slug":"catch","permalink":"https://chuhang123.github.io/tags/catch/"},{"name":"try","slug":"try","permalink":"https://chuhang123.github.io/tags/try/"},{"name":"error","slug":"error","permalink":"https://chuhang123.github.io/tags/error/"}]},{"title":"ArrayList、LinkedList和HashSet的学习总结","date":"2017-11-15T01:00:51.000Z","path":"2017/11/15/java-dynamic-data-structure/","text":"java中，一旦程序定义了数组的长度，就不能修改这个数组的长度了。如果我们需要修改数组的长度，我们可以使用ArrayList，以达到改变数组长度的目的。 类ArrayListArrayList的缺点： ArrayList比数组的效率低 ArrayList只能存储对象，不能包含基本类型，比如int、double。 ArrayList的语法：1ArrayList &lt;Base_Type&gt; Variable = new ArrayList&lt;Base_Type&gt;(Capacity); 其中，Base_Type必须为类类型，不能为基本类型。Capacity（容量）表示为这个数据项分配内存空间，如果不传值，默认初始容量为10个数据项。如果初始化给了足够大的初始容量，那么系统就不需要频繁的分配内存了，程序将会运行的更快。反之，如果你吧初始容量弄得太大，就会浪费储存空间。我们对是否分配容量做一个测试，代码实例：1234567891011121314151617181920public class ListDemo &#123; static long timeList(List&lt;String&gt; st) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; st.add(String.valueOf(i)); &#125; return System.currentTimeMillis() - start; &#125; public static void main (String args[]) &#123; System.out.println(\"assign capacity ArrayList = \" + timeList(new ArrayList&lt;String&gt;(100000))); System.out.println(\"default ArrayList = \" + timeList(new ArrayList&lt;String&gt;())); &#125; &#125; 结果如下：12assign capacity ArrayList = 22default ArrayList = 13 jdk7之前，我们应该这样实例化ArrayList1List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;(); jdk7开始，我们可以这样1List&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); 不仅方便了我们书写，也使代码有更强的可读性。 类LinkedList类LinkedList的基本用法同上，但是LinkedList内部使用双向链表的数据结构，只有在需要时才分配内存，删除元素时随即释放内存。 类ArrayList和类LinkedList的比较 类LinkedList插入元素效率高，但访问元素效率低。 类ArrayList访问元素效率高，但插入效率低。他们的效率相差多少，我们通过实例来了解（仅修改main方法）：1234567public static void main (String args[]) &#123; System.out.println(\"time for ArrayList = \" + timeList(new ArrayList&lt;String&gt;())); System.out.println(\"time for LinkedList = \" + timeList(new LinkedList&lt;String&gt;()));&#125; 运行结果：12time for ArrayList = 22time for LinkedList = 13 如果我们指定位置添加元素，将第六行代码st.add(String.valueOf(i));修改为st.add(0, String.valueOf(i));运行结果为：12time for ArrayList = 915time for LinkedList = 11 为什么会差这么多呢，因为每插入一个元素，arraylist都要吧所有的元素都后移，而LinkedList指需要增加一个新的结点，并调整一下对应关系就可以了。我们进行一次新增元素，再进行一次查看元素，他们的效率相差多少呢？将timeList修改为如下所示：1234567891011static long timeList(List&lt;String&gt; st) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; st.add(String.valueOf(i)); &#125; for (int i = 0; i &lt; 10000; i++) &#123; st.get(i); &#125; return System.currentTimeMillis() - start;&#125; 结果如下123time for ArrayList = 17time for LinkedList = 156 因此，我们在进行相同次数的查找和添加元素的情况下，ArrayList效率较高。因此，我们使用ArrayList的次数会更多一些。 Collection API的层次结构通过上面的学习，我们对动态数据结构有了基本的认识，那么java中关于数组的接口和实现类的层次结构是什么样的呢？如下图：由上图可知，Iterable接口、Collection接口中定义的方法，几个实现类都实现了，只不过他们的具体实现方法会有所差异。同样的，ArrayList和LinkedList都是List接口的实现类，所以他们的方法名都是一样的，但是具体的实现方法有所差异。 Set接口和List接口1.Set对应的中文名是集合，有两个特点： 不含重复元素 无序 2.List接口类似于书续重的序列，也有两个特点： 可含重复的元素 有序 类HashSetHashSet继承了Set接口的特性，值得注意的是，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法中使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果。因为new一个HashSet，实际上是new HashMap，并以这个对象的hashCode为key，这个对象本身为value储存。当对象的hashcode改变后，我们可以使用迭代器进行删除的操作，代码如下：12345678Iterator&lt;MandatoryInstrument&gt; iterator = mandatoryInstrumentList.iterator();while (iterator.hasNext()) &#123; MandatoryInstrument mandatoryInstrument = iterator.next(); if (mandatoryInstrument.getCheckDepartment() == null) &#123; iterator.remove(); continue; &#125;&#125; iteratoriterator（迭代器）是什么？eg：123for (int i = 0; i &lt; 10000; i++) &#123; st.get(i);&#125; 那么，i就是一个迭代器——能够以合理的方式一次访问一个元素、遍历整个数组或者链表的变量。从一个元素走到另一个元素的过程就是是迭代（iterable）","tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"https://chuhang123.github.io/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://chuhang123.github.io/tags/LinkedList/"},{"name":"HashSet","slug":"HashSet","permalink":"https://chuhang123.github.io/tags/HashSet/"},{"name":"iterator","slug":"iterator","permalink":"https://chuhang123.github.io/tags/iterator/"},{"name":"数组","slug":"数组","permalink":"https://chuhang123.github.io/tags/数组/"}]},{"title":"angular和springmvc实现批量删除","date":"2017-10-21T12:14:05.000Z","path":"2017/10/21/angular-spring-batch-delete/","text":"昨天实现了批量删除的功能，看到了stackoverflow和百度上均有相关的问题，于是决定记录一下。前台angularjs，后台SpringMvc。 checkbox使用123&lt;tr ng-repeat=\"(key, object) in data.content\"&gt; &lt;td&gt;&lt;input icheck type=\"checkbox\" ng-model=\"object._checked\"&gt;&lt;/td&gt;&lt;/tr&gt; 当用户勾选复选框后，对象的_checked属性值为true，我们通过下面这个函数获取勾选的object,可以把这个函数放在公共service中，方便框架的其他地方调用。类似的，我们也可以根据自己的需求，修改_checked属性。123456789101112131415161718192021/** * 由某个数组中 筛选中被选中的元素，组成新的数组并返回 * @param &#123;array&#125; lists 原数组 * @param &#123;string&#125; key 健值 默认为 _checked * @return &#123;array&#125; 选中元素组成的数组 * @author 梦云智 http://www.mengyunzhi.com * @DateTime 2017-10-17T15:05:18+0800 */self.getCheckedElementsByListsAndKey = function(lists, key) &#123; if (typeof(key) === 'undefined') &#123; key = '_checked'; &#125; var tempList = []; angular.forEach(lists, function(list) &#123; if (typeof(list[key]) !== 'undefined' &amp;&amp; list[key] === true) &#123; tempList.push(list); &#125; &#125;); return tempList;&#125;; 前后台对接前台http请求12345678var data = [1, 3, 4]; // 假设要删除id为1,3,4的记录$http.delete('/FromMessage/batchDelete/' + data) .then(function success(response)&#123; if (callback) &#123;callback(response.status);&#125; &#125;, function error(response)&#123; alert('FromMessage.batchDelete error: ', response); if (callback) &#123;callback(response.status);&#125; &#125;); 后台代码123456@ResponseStatus(HttpStatus.NO_CONTENT) @DeleteMapping(\"/batchDelete/&#123;fromMessageIds&#125;\") public void batchDelete(@ApiParam(value = \"消息id数组\") @PathVariable List&lt;Integer&gt; fromMessageIds) &#123; fromMessageService.batchDelete(fromMessageIds); return; &#125; 后台接受到的是一个数组。如果把数组放到delete方法的body中，由于不符合api规范，会被tomcat或这spring丢弃，后台就不能正确的接受body信息。 单元测试功能实现后，为了降低代码的维护成本，我们进行单元测试。这里给出示例代码：12345logger.info(\"模拟请求\");this.mockMvc.perform(delete(\"/FromMessage/batchDelete/\" + fromMessage.getId() + ',' + fromMessage1.getId()).header(\"x-auth-token\", xAuthToken)).andDo(document(\"FromMessage_batchDelete\", preprocessResponse(prettyPrint()))).andExpect(status().is(204)); 注意请求的url1/FromMessage/batchDelete/2,3 总结在进行开发的时候，实现复选框选中、后台接收数组等功能，感觉之前都实现过，但是由于记得不清楚，测试了多次也没能通过，还是及时的google能够节约解决问题的时间。","tags":[{"name":"http","slug":"http","permalink":"https://chuhang123.github.io/tags/http/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://chuhang123.github.io/tags/SpringMVC/"},{"name":"batch","slug":"batch","permalink":"https://chuhang123.github.io/tags/batch/"},{"name":"delete","slug":"delete","permalink":"https://chuhang123.github.io/tags/delete/"},{"name":"checkbox","slug":"checkbox","permalink":"https://chuhang123.github.io/tags/checkbox/"}]},{"title":"java中json和object相互转换","date":"2017-10-21T08:45:14.000Z","path":"2017/10/21/how-to-convert-json-to-from-object-Gson/","text":"我们经常会用到json和oject类型的相互转换，这篇文章记录了通过gson进行object和json的相互转换。 gson 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt; object转换为json123456789// 1.新建一个对象FromMessage fromMessage = new FromMessage();fromMessage.setContent(\"test\");fromMessage.setIsRead(Boolean.FALSE);// 2.将对象转化为json字符串Gson gson = new Gson();String jsonString = gson.toJson(fromMessage);System.out.println(jsonString); // &#123;\"content\":\"test\",\"isRead\":false&#125; json转化为object1234Gson gson = new Gson();String jsonString = \"&#123;\\\"content\\\":\\\"test\\\",\\\"isRead\\\":false&#125;\";FromMessage fromMessage1 = gson.fromJson(jsonString, FromMessage.class);System.out.println(fromMessage1); //Message&#123;id=null, content='test', title='null', isRead=false, fromDepartment=null, toDepartment=null, firstReadTime=null, firstReadUser=null, createUser=null, createTime=null&#125; 参考文章：How to convert Java object to JSON string","tags":[{"name":"json","slug":"json","permalink":"https://chuhang123.github.io/tags/json/"},{"name":"object","slug":"object","permalink":"https://chuhang123.github.io/tags/object/"},{"name":"gson","slug":"gson","permalink":"https://chuhang123.github.io/tags/gson/"}]},{"title":"学习hebinate继承映射关系","date":"2017-10-17T09:18:58.000Z","path":"2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/","text":"做计量项目我的消息模块时，消息分为接收消息和发送消息，如果把消息放在一个实体中，当删除发送消息时，对应的接受消息也被删除了，因此决定使用继承的方法。我们通过这个问题学习ＪＰＡ主要的三种映射策略。 问题还原假设有三个类animal、cat、dog。cat、dog继承animal类那我们应该通过什么方法生成数据表，生成几张数据表呢，哪种方法最优呢？ 单表继承策略单表继承，就是这几个类共用一个数据表。代码如下：123456789101112131415161718192021222324@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 继承（策略 = 单表继承）@DiscriminatorColumn(name = \"DB_TYPE\") // 鉴别的列名为 DB_TYPE，将在数据表中生成该字段，用与区分子表类型public abstract class Animal implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String age; // 省略constructor 、getters、setters&#125;@Entity@DiscriminatorValue(\"Cat\")public class Cat extends Animal &#123; private String weight;&#125;@Entity@DiscriminatorValue(\"Dog\")public class Dog extends Animal &#123; private String height;&#125; 生成了一张数据表： 这种方法不仅简单，而且性能也是最优的。因为每个子类使用了@Entity注解，子类的属性都会被映射到Animal表的列中。 这种方法在子类中使用@NotNull注解会被hibernate忽略，因为如果你定义了Dog类的height属性不能为null，但是当保存cat类的数据时，height必然为null。 JOINED策略代码如下：12345678910111213141516171819@Entity@Inheritance(strategy = InheritanceType.JOINED) // 继承（策略 = TABLE_PER_CLASS）public abstract class Animal &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) // 不能使用自动生成主键策略 private Long id; private String age;&#125;@Entitypublic class Dog extends Animal &#123; private String height;&#125;@Entitypublic class Cat extends Animal &#123; private String weight;&#125; 此时生成了三张表我们可以看到dog和cat表中并没有age属性当我们想获取age属性时，我们通过左链接的方式取值。 TABLE_PER_CLASS策略这种策略不能使用自动生成主键的策略，代码如下：12345678910111213141516171819@Entity@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) // 继承（策略 = TABLE_PER_CLASS）public class Animal &#123; @Id //@GeneratedValue(strategy = GenerationType.AUTO) // 不能使用自动生成主键策略 private Long id; private String age;&#125;@Entitypublic class Cat extends Animal &#123; private String weight;&#125;@Entitypublic class Dog extends Animal &#123; private String height;&#125; 生成了三张数据表：如果把Animal改为abstract类，则只会生成两张表 总结学习了以上三种方式，那么我们在什么情况下使用他们呢？ 当父类的属性较多时，我们使用InheritanceType.SINGLE_TABLE策略，已达到最少可为空的列的数量。 当父类的属性较少，而子类的属性较多时，我们使用InheritanceType.JOINED策略。 当我们很少对父类进行操作时，我们使用InheritanceType.TABLE_PER_CLASS策略，这种方法倾向于把每一个类对应一个具体的表。","tags":[{"name":"JPA","slug":"JPA","permalink":"https://chuhang123.github.io/tags/JPA/"},{"name":"inheritance","slug":"inheritance","permalink":"https://chuhang123.github.io/tags/inheritance/"},{"name":"entity","slug":"entity","permalink":"https://chuhang123.github.io/tags/entity/"},{"name":"map","slug":"map","permalink":"https://chuhang123.github.io/tags/map/"}]},{"title":"SpringMVC+Angularjs上传图片","date":"2017-10-10T07:24:23.000Z","path":"2017/10/10/SpringMVC-Angularjs-upload-image/","text":"最近，完成了图片上传的功能，中间也遇到了一些问题，本文记录了上传图片的代码段，希望下次开发相同的功能时尽可能的节约时间。环境：后台SpringMvc，前台angularjs，前台插件angular-file-upload 。 开发思路 开发顺序：先开发前台，再开发后台。从而避免开发后台的功能后，前台不需要此功能的情况。 前台开发：我们把图片作为一个指令，以方便在各个模块中的使用。引入angular-file-upload插件。 后台应该建立图片相关实体，后台获取到图片后，对文件流进行sha1或md5加密，判断如果后台服务器已经存在相同的图片，则不在上传该图片，直接引用之前上传的图片，以节约服务器资源。类似地，删除图片时，也应该判断是否改图片被引用多次，如果被引用多次，则不需要删除服务器中的图片，只删除图片实体中的那一条记录即可。如果用户要删除的图片只被引用一次，则删除图片实体中的记录，并删除服务器中的图片，释放服务器资源。同时，参考官方文档 ，并根据前台需求，完成后台功能代码。 通过这种方法，如果用户上传较大的文件，且服务器之前已经上传过相同的文件，那么就可以实现秒传，同时节约了服务器的资源。所以，有时我们在一些平台上（如迅雷）上传几百兆或者几个Ｇ的文件，也可秒传，并不是网速很快，而是因为服务器上已经存在相同的文件。 给出附件实体实例12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity@ApiModel(value = \"Attachment (附件)\", description = \"附件\")public class Attachment implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @ManyToOne @ApiModelProperty(\"操作用户\") private User operator; @ApiModelProperty(\"sha1值\") private String sha1; @ApiModelProperty(\"md5值\") private String md5; @ApiModelProperty(\"附件扩展名\") private String ext; @ApiModelProperty(\"附件大小\") private String size; @ApiModelProperty(\"附件上传时间\") private Long createTime; @ApiModelProperty(\"附件更新时间\") private Long updateTime; @ApiModelProperty(\"附件名称\") private String name; @ApiModelProperty(\"附件存储路径\") private String savePath; @ApiModelProperty(\"附件存储名称\") private String saveName; @ApiModelProperty(\"MIME类型\") private String MIME; // 省略constructor、getters、setters 前台代码界面的效果图如下： 前台代码放在github上，代码地址：https://github.com/chuhang123/blog/tree/master/2017/uploadImage 。 在前台代码中，我们需要对图片标题长度过滤 ，代码如下：12345678910111213// 长度为２０return function (input) &#123; var r=/[^\\x00-\\xff]/g; if(input.replace(r,\"mm\").length&lt;=20)&#123;return input;&#125; var m=Math.floor(20/2); for(var i=m;i&lt;input.length;i++)&#123; if(input.substr(0,i).replace(r,\"mm\").length&gt;=20)&#123; return input.substr(0,i)+\"...\"; &#125; &#125; return input;&#125;; 显示图片的缩略图 ，并根据项目需求请求后台代码。 后台代码在后台的附件控制器中建立三个请求借口：删除、上传、图片访问入口。同时参考官方文档 。 如上图所示，需要注意４个地方： 预览图片时，我们要根据图片的保存名称来浏览图片，我们要使用{saveName:.+}获取图片的名称，否则不能正确获取图片的名称。 参考官方教程浏览图片时，控制台会抛出HttpMessageNotWritableException异常，我们需要设置响应信息的内容类型，就把这个异常给解决了。 官方文档是把文件流放在响应信息中，但这种方式相当消耗服务器的资源，假设一个图片１Ｍ，有１００个并发请求，那么就要消耗服务器１００Ｍ的内存，那么如果有更多的并发请求，那么就非常消耗资源。所以等项目上线后把开放图片路径，以节约服务器资源。 上传的图片类型为MultipartFile, 所以前台的请求内容类型应该为Content-Type:multipart/form-data，请求实例如下：1234567var formData = new FormData();formData.append('attachment', image);$http.post(url, formData, &#123;transformRequest: angular.identity,headers: &#123;'Content-Type': undefined&#125;&#125;)........ 设置图片大小上限，在配置文件中增加如下代码： 123// 设置图片最大为３Ｍspring.http.multipart.max-file-size=3072KB spring.http.multipart.max-request-size=3072KB 当其他实体和附件相关时，比如强检申请：附件=1：n，因为可能还会有很多实体和附件相关联，因此在强检申请实体中使用@OneToMany单向映射较为合适。为了操作方便，通过使用 @JoinColumn不再建立中间表。 12@OneToMany @JoinColumn(name = \"mandatoryInstrumentApply_id\") 因为我们需要对MultipartFile类型的文件进行sha1、md5加密，所以这里给出hash加密算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 根据指定的算法加密文件数据, 返回固定长度的十六进制小写哈希值 * * @param multipartFile 需要加密的文件 * @param algorithm 加密算法, 例如: MD5, SHA-1, SHA-256, SHA-512 等 */ static String encrypt(MultipartFile multipartFile, String algorithm) throws Exception &#123; InputStream in = null; try &#123; // 1. 根据算法名称获实现了算法的加密实例 MessageDigest digest = MessageDigest.getInstance(algorithm); in = multipartFile.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 2. 文件数据通常比较大, 使用 update() 方法逐步添加 digest.update(buf, 0, len); &#125; // 3. 计算数据的哈希值, 添加完数据后 digest() 方法只能被调用一次 byte[] cipher = digest.digest(); // 4. 将结果转换为十六进制小写 return bytesToString(cipher); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (Exception e) &#123; // nothing &#125; &#125; &#125; &#125; // 将字节转为字符串 static String bytesToString(byte[] bytes) &#123; if (bytes == null || bytes.length == 0) &#123; return null; &#125; StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(HEXES[(b &gt;&gt; 4) &amp; 0x0F]); stringBuilder.append(HEXES[b &amp; 0x0F]); &#125; return stringBuilder.toString(); &#125; // 十六进制字符数组 static char[] HEXES = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; 总结这次附件上传花费了较长的时间，一方面水平不够，一方面有些追求完美，从而耽误了时间，所以完成任务是第一位的，切忌追求完美。望以后注意。","tags":[{"name":"angular","slug":"angular","permalink":"https://chuhang123.github.io/tags/angular/"},{"name":"js","slug":"js","permalink":"https://chuhang123.github.io/tags/js/"},{"name":"upload","slug":"upload","permalink":"https://chuhang123.github.io/tags/upload/"},{"name":"image","slug":"image","permalink":"https://chuhang123.github.io/tags/image/"},{"name":"angularFileUpload","slug":"angularFileUpload","permalink":"https://chuhang123.github.io/tags/angularFileUpload/"}]},{"title":"学习JPA的@OneToMany注解","date":"2017-10-09T07:05:43.000Z","path":"2017/10/09/Learning-JPA-OneToMany/","text":"在JPA中，最常用的关系大概就是一对多了。假设实体A、B的关系为A:B=1:n，通常情况下，我们会在B实体中使用@ManyToOne的注解。但是有时我们需要在A实体中使用@OneToMany的注解，那么我们应该怎么办呢？ 以下代码中，假设实体One和Many的关系为One:Many=1:n 单向映射@OneToMany我们只在One实体中使用注解，代码如下12345678910111213141516171819@Entitypublic class One &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @OneToMany private List&lt;Many&gt; manys = new ArrayList&lt;&gt;(); // 省略构造函数，getters and setters&#125;@Entitypublic class Many &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name;&#125; 生成的数据表如下：1234567891011121314151617181920212223MariaDB [springmvc]&gt; select * from one;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from many;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from one_manys;+--------+----------+| one_id | manys_id |+--------+----------+| 1 | 1 |+--------+----------+1 row in set (0.00 sec) 现在，我们如果想要在中间表中存一条记录，就必须先要保证many实体中存在一条记录，然后保存one对象时设置和many的关联关系？代码如下：123456789101112logger.info(\"新建One实体\");One one = new One();logger.info(\"新建并保存Many实体\");Many many = new Many(\"test\");manyRepository.save(many); // 能不能省略这行代码呢？logger.info(\"保存\");List&lt;Many&gt; manies = new ArrayList&lt;&gt;();manies.add(many);one.setManys(manies);oneRepository.save(one); 我们能不能省略manyRepository.save(many);，答案是可以的。直接在One实体中的@OneToMany注解后面加入括号(cascade = CascadeType.ALL, orphanRemoval = true)，JPA仍然会自动保存many实体。 此时，如果我们把Many实体表中id为1的记录删除，会报一个外键约束的错误，我们需要先把one_manys表中的记录删除，才可以删除Many实体表中id为1的记录。这样是不是有点麻烦呢？有没有办法直接删除Many实体中的记录呢？我们在One实体中增加一个注解@JoinColumn就可以了，代码如下： 12345678910@Entitypublic class One &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @OneToMany @JoinColumn(name = \"many_id\") private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();&#125; 数据表的结构如下：123456789101112131415161718MariaDB [springmvc]&gt; select * from one;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from many;+----+------+---------+| id | name | many_id |+----+------+---------+| 1 | test | 1 |+----+------+---------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from one_manys;ERROR 1146 (42S02): Table 'springmvc.one_manys' doesn't exist 这样就不会增加中间表了，此时我们可以直接删除many实体中的记录了。 双向映射@OneToMany代码如下：12345678910111213141516171819@Entitypublic class Many &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @ManyToOne private One one;&#125;@Entitypublic class One &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @OneToMany private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();&#125; 生成的数据表如下：1234567891011121314151617181920212223MariaDB [springmvc]&gt; select * from one_manys;+--------+----------+| one_id | manys_id |+--------+----------+| 1 | 1 |+--------+----------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from many;+----+------+--------+| id | name | one_id |+----+------+--------+| 1 | test | 1 |+----+------+--------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from one;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec) 总结我们经常会用到实体间的关系，但是往往在实际的项目中，由于项目过于庞大，增加了学习成本。因此，比较好的学习方法就是在一个测试的项目中学习，减少学习成本。 参考链接：The best way to map a @OneToMany relationship with JPA and Hibernate","tags":[{"name":"JPA","slug":"JPA","permalink":"https://chuhang123.github.io/tags/JPA/"},{"name":"OneToMany","slug":"OneToMany","permalink":"https://chuhang123.github.io/tags/OneToMany/"},{"name":"映射","slug":"映射","permalink":"https://chuhang123.github.io/tags/映射/"},{"name":"单向","slug":"单向","permalink":"https://chuhang123.github.io/tags/单向/"}]},{"title":"js的浅拷贝和深拷贝学习","date":"2017-10-08T08:31:00.000Z","path":"2017/10/08/js-deep-copy-and-shallow-copy/","text":"最近做项目时，发现把A赋值给B，当我改变B时，A也随之改变了。google了一下，了解到在js中，当一个变量复制另一个变量时，其实复制的是一个地址，改变其中一个变量，另一个也会随之改变。 这种复制分两种情况：拷贝引用（浅拷贝）和拷贝实例（深拷贝） 浅copy 拷贝原对象的引用 123456var o1 = &#123;a: 1&#125;;var o2 = o1;console.log(o1 === o2); // =&gt;trueo2.a = 2; console.log(o1.a); // =&gt; 2 拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用 12345678910var o1 = ['darko', &#123;age: 22&#125;];var o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的浅拷贝对象console.log(o1 === o2); // =&gt; false，说明o2拷贝的是o1的一个实例o2[0] = 'lee';console.log(o1[0]); // =&gt; \"darko\" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响o2[1].age = 23;console.log(o1[1].age); // =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响 浅copy实现123456789101112function shallowClone(source) &#123; if (!source || typeof source !== 'object') &#123; throw new Error('error arguments'); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; targetObj[keys] = source[keys]; &#125; &#125; return targetObj;&#125; 深copy深copy有两种方法 使用JSON.stringify和JSON.parse。JSON.parse(JSON.stringify(object))。这种方法只能copy对象的属性，不能copy对象的方法。 使用递归的方法实现1234567891011121314151617function deepClone(source)&#123; if(!source || typeof source !== 'object')&#123; throw new Error('error arguments', 'shallowClone'); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for(var keys in source)&#123; if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === 'object')&#123; targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125; 参考链接： JavaScript中的浅拷贝和深拷贝 javascript中的深拷贝和浅拷贝？","tags":[{"name":"deep","slug":"deep","permalink":"https://chuhang123.github.io/tags/deep/"},{"name":"shallow","slug":"shallow","permalink":"https://chuhang123.github.io/tags/shallow/"},{"name":"copy","slug":"copy","permalink":"https://chuhang123.github.io/tags/copy/"},{"name":"clone","slug":"clone","permalink":"https://chuhang123.github.io/tags/clone/"},{"name":"assignment","slug":"assignment","permalink":"https://chuhang123.github.io/tags/assignment/"}]},{"title":"windows10/ubuntu双系统安装记录","date":"2017-09-18T06:00:01.000Z","path":"2017/09/18/windows-ubuntu-double-system-install-record/","text":"因为要换硬盘，所以要重新安装win10和ubuntu系统。把中间遇到的一些问题记录了下来。 安装win10系统首先，下载了一个win10的iso文件，通过UltraISO刻录到U盘中。把新的硬盘装进电脑，启动，按下F12，把U盘作为第一启动项，然后界面一直循环出现如下代码123No Systemdisk. Booting from harddisk.Start booting from USB device...Disk formatted with UltraISO 9.0(c) 2002-2008 EZB System,Inc 然后google了这个问题，有说是写入方式不对，或者没有把U盘作为第一启动项等，或者是iso文件的问题。我感觉可能行较大的是写入方式不对，刻录了多次，换了多种的写入方式，然而还是不行。最后，去网吧使用韩博士安装系统的方式，重新下载了一个iso文件，win10系统就重装成功了。 安装ubuntu系统安装ubuntu同样使用UltraISO刻录到U盘的方法，重启电脑一切正常，然后开始搭建java、maven、node、git等环境，配置完之后，以为大功告成。然而发现不能重启ubuntu系统了，此时心情是崩溃的，最终发现可以从高级选项中进入ubuntu系统，进入系统后，google了一番，决定使用boot repair修理一下，修理完之后，发现ubuntu、win10系统都进不去了，直接显示grub命令行。这是很揪心的，毕竟平时的一些资料都在里面。查找了一些解决办法，并没有解决。只能再次重装系统。 再次重装系统但是应该重装那个呢。因为是后装的ubuntu系统，所以启动的时候win10是通过ubuntu启动的，问了下老师，如果重装win10系统，win10系统有一个启动修复的方法，挽救会win10系统，ubuntu系统就废掉了。 当时比较纠结如果直接重装ubuntu系统，还能不能通过新装的ubuntu系统进入到之前安装的win10系统，经过实践之后发现是可以的。 当时有ubuntu的iso文件，就先装了ubuntu系统试试，按照上一次安装ubuntu的方法，装完后，很是担心重复出现上一次的情况。老师问了下我的安装方式，说我安装类型哪一步有错误。我选择的是默认安装，所以ubuntu系统可能出问题，应该手动进行分区。于是就参考Windows10+Ubuntu双系统安装[多图] （手动的进行分区）又重新安装了一下ubuntu系统，之后一切顺利。 参考链接：1.Windows10+Ubuntu双系统安装[多图]","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://chuhang123.github.io/tags/ubuntu/"},{"name":"win10","slug":"win10","permalink":"https://chuhang123.github.io/tags/win10/"}]},{"title":"java 常见异常及原因收集","date":"2017-09-07T02:21:57.000Z","path":"2017/09/07/java-exception-and-cause/","text":"InvalidDataAccessApiUsageException: 单元测试时关联的实体未保存。 java.nio.file.NoSuchFileException:因为目录不存在，通过 Files.createDirectories(imageLocation);创建目录 JpaSystemException: 重建数据表","tags":[{"name":"java","slug":"java","permalink":"https://chuhang123.github.io/tags/java/"}]},{"title":"GLib-GIO-ERROR **: Settings schema xxx  is not installed","date":"2017-08-27T03:08:24.000Z","path":"2017/08/27/GLib-GIO-ERROR-Settings-schema-xxx-is-not-installed/","text":"今天安装peek的时候，报了这么一行错误123(peek:11612): GLib-GIO-ERROR **: Settings schema 'com.uploadedlobster.peek' is not installedTrace/breakpoint trap (core dumped) 首先对问题简单分析一下，大致是com.uploadedlobster.peek这个包没有没安装，或者安装了找不到，可是这个包应该怎么安装呢。 第一步，还是老方法，把这行代码放到谷歌上，但并没有找到问题的解决方案。 接下来，就是找类似问题的解决方案，Settings schema is not installed，但是由于英文阅读能力不行，没有发现问题的解决方案。 然后卸载，尝试sudo apt install -f peek，安装相关的依赖，并没有什么用。 一番无奈之后，以Settings schema is not installed 解决方案为关键字，解决了该问题。 解决方法1glib-compile-schemas /usr/share/glib-2.0/schemas 执行完上述命令，peek就可以用了。可能和/usr/share/glib-2.0/schemas文件下的com.uploadedlobster.peek.gschema.xml文件有关系。 参考文献： ubuntu的Files资源管理器打不开解决方案","tags":[{"name":"install","slug":"install","permalink":"https://chuhang123.github.io/tags/install/"}]},{"title":"HTTP常见状态码 200 301 302 404 500","date":"2017-08-09T12:29:58.000Z","path":"2017/08/09/http-staus-code/","text":"一些常见的状态码为： 1开头1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码。代码 说明100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 2开头2xx (成功)表示成功处理了请求的状态代码。代码 说明 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 (已创建) 请求成功并且服务器创建了新的资源。 202 (已接受) 服务器已接受请求，但尚未处理。 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206 (部分内容) 服务器成功处理了部分 GET 请求。 3开头 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。代码 说明 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。代码 说明 400 (错误请求) 服务器不理解请求的语法。 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 (禁止) 服务器拒绝请求。 404 (未找到) 服务器找不到请求的网页。 405 (方法禁用) 禁用请求中指定的方法。 406 (不接受) 无法使用请求的内容特性响应请求的网页。 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。 408 (请求超时) 服务器等候请求时发生超时。 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 (未满足期望值) 服务器未满足”期望”请求标头字段的要求。 5开头5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。代码 说明 500 (服务器内部错误) 服务器遇到错误，无法完成请求。 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。 转自：HTTP常见状态码 200 301 302 404 500","tags":[{"name":"http","slug":"http","permalink":"https://chuhang123.github.io/tags/http/"}]},{"title":"spring装配bean——自动化装配、java显式装配","date":"2017-08-01T03:00:39.000Z","path":"2017/08/01/spring-wiring-bean/","text":"当我们在使用Spring框架时，您可能会见到@bean注解，初学者可能会疑惑@bean是如何发挥作用的？带着这个疑问我们来探究spring装配bean的相关知识。 Spring配置bean的可选方案spring提供了三种主要的装配机制 隐式的自动化装配bean 在java中显式的配置 在XML中显式的配置 spring实战书中，建议在实际的项目中尽可能的使用自动配置的机制，显示配置越少越好。当必须要使用显示的配置时，建议优先使用JavaConfig，只有在你想使用便利的xml命名空间时，才应该使用xml。 自动化装配bean 定义一个接口 1234567package soundsystem;public interface CompactDisc &#123; void play();&#125; 定义一个带有@Component注解的CompactDisc实现类SgtPeppers 1234567891011package soundsystem;import org.springframework.stereotype.Component;@Component //表明该类为组件类，并告知Spring为这个类创建beanpublic class SgtPeppers implements CompactDisc &#123; public void play() &#123; System.out.println(\"this is a test\"); &#125;&#125; Spring会为SgtPeppers的bean设置ID为sgtPeppers，我们也可以指定bean的ID，比如我们要指定bean的ID为mengyunzhi，那么应该@Component(“mengyunzhi”)。 @ComponentScan注解启用了组件扫描12345678package soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan //启用组件扫描。注意：需要和@Configuration注解一起使用public class CDPlayerConfig &#123;&#125; @ComponentScan默认会扫面与CDPlayerConfig（配置类）相同的包。即扫描soundsystem包以及这个包下的所有子包。那么他是怎么扫描的呢？他会查找带有@Component注解的类，并会在Spring中自动创建一个bean。如果要需要设置组件扫描的包，可以使用@ComponentScan(“com.my.package.first”)，如果要扫描多个包，可以修改为@ComponentScan({“com.my.package.first”,”com.my.package.second”}) 通过java代码装配bean去除上例中的@ComponentScan注解和@Component注解，我们使用java代码显示声明bean。12345678910111213package soundsystem;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class CDPlayerConfig &#123; @Bean public CompactDisc compactDisc() &#123; return new SgtPeppers(); &#125;&#125; @Bean注解会告诉spring该方法会返回一个对象，该对象即为产生的bean实例。默认bean的ID为方法名，我们也可以使用@Bean(name=”xxxx”)设置bean的ID。 延伸 如果我们同时创建两个相同的bean，会怎么样呢？12345678@Bean public CompactDisc compactDisc() &#123; return new SgtPeppers(); &#125; @Bean public CompactDisc anotherCompactDisc() &#123; return new SgtPeppers(); &#125; Spring不会创建两个完全相同的bean。所以，当我们创建第二个bean时，spring会拦截并返回已经创建的bean。 如果您使用了SpringBoot框架，你可能会疑惑并没有看到@Configuration、@ComponentScan注解，那是因为我们经常会一起使用@Configuration, @EnableAutoConfiguration 和 @ComponentScan，所以@SpringBootApplication等同于@Configuration, @EnableAutoConfiguration and @ComponentScan。另外，当我们使用@Service, @Repository, @Controller注解时，spring会认为该类为组件类，spring也会为我们创建bean。 当我们打开idea的spring来查看项目为我们创建的bean时，我们会发现一些接口如WorkRepository，并没有使用任何注解，但是生成了bean，这是为什么呢？那是因为 @EnableAutoConfiguration也有@EnableJpaRepositories的功能，basePackage配置项会自动扫描当前包下的Repository并生成bean。","tags":[{"name":"bean","slug":"bean","permalink":"https://chuhang123.github.io/tags/bean/"},{"name":"装配","slug":"装配","permalink":"https://chuhang123.github.io/tags/装配/"},{"name":"自动化","slug":"自动化","permalink":"https://chuhang123.github.io/tags/自动化/"}]},{"title":"https初步学习之——原理、性能","date":"2017-07-16T01:51:34.000Z","path":"2017/07/16/http-and-https/","text":"一直听说https比http安全，https 是加过密的http。但是https具体是怎样加SSL/TLS协议运行机制的概述 密认证的？http和https的安全性区别在哪里？https对服务器性能有什么影响？带着这些疑问查阅了相关资料，并记录。 http和https的区别不使用SSL/TLS的通信，就是我们所说的http通信，有以下三种风险： 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 当我们对http通信使用SSL/TLS协议后，就是我们所说的https通信，希望达到： 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 https通信过程时序图如下 说明： 步骤1中的证书包含了公钥、颁证机构、网址、过期时间。 如果服务器端需要客户端提供证书，则会在步骤1中的返回信息中增加一个参数（要求客户端提供证书），那么步骤4中也会增加一个参数（客户端证书）。 客户端和服务器端生成对称密钥后，之后所有的通信都使用对称秘钥加密。 结合实例当一个人（小明）登录一个网站后，该网站的服务器会为小明分配一个sessionId，发送给客户端，当小明再次请求这个服务器时，携带着上次分配的sessionId，这样服务器就知道是小明访问的网站了。 假设这个请求是http请求。那么，第三方就可以获取这个请求的信息，获取sessionId。然后携带着这个sessionId模拟http请求，那么服务器就会认为是小明发送的请求，第三方就可以获取、修改小明的数据等。 假设这个请求是https请求。同样的，第三方获取到了请求的相关信息，但是并不知道这里面的内容是什么，因为这些数据都是经过加密的。如果别人修改了数据，服务器也会知道这个数据被别人修改了，因为SSL/TLS协议对数据通过hash算法（如sha1、md5）加密，加密结果不一致，就会被认为内容被篡改过了。通过上面两个实例，你会不会认为使用https就一定安全呢？如果是，那你就错了。https只能保证内容在传输的过程中不会被别人篡改或者窃取。但是，如果数据在客户端或者服务器端被窃取或者修改，也一样存在风险。 http和https对服务器性能的影响网站实现https，国外比较普及，但是在国内很多网站并没有使用https，其中一个比较重要的原因是网站的用户体验和性能下降明。那么使用https对网站的性能到底有多大的影响呢？ http使用TCP 三次握手建立连接，客户端和服务器需要交换3个包，https除了 TCP 的三个包，还要加上 ssl握手需要的9个包，所以一共是12个包。一个链接测试，http是114毫秒；https建立连接，耗费436毫秒。ssl 部分花费322毫秒。你可能会问，每一次请求都需要那么多时间么？答案是否定的，第一次进行https通信时握手阶段生成的对称秘钥后，接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。在HTTP与HTTPS性能 文章中，提出了具体的优化方案，期待将来有机会在项目实战中使用到。 参考文献： HTTP 必死：先知 Google 唿吁大家升级 HTTPS， 网页浏览更有保障 http 和 https 有何区别？如何灵活使用？ 扒一扒HTTPS网站的内幕 SSL/TLS协议运行机制的概述 https时序图","tags":[{"name":"https","slug":"https","permalink":"https://chuhang123.github.io/tags/https/"},{"name":"安全","slug":"安全","permalink":"https://chuhang123.github.io/tags/安全/"},{"name":"服务器","slug":"服务器","permalink":"https://chuhang123.github.io/tags/服务器/"},{"name":"性能","slug":"性能","permalink":"https://chuhang123.github.io/tags/性能/"}]},{"title":"SpringMVC实现session分布式管理","date":"2017-07-05T19:48:23.000Z","path":"2017/07/06/Using-session-in-SpringMVC/","text":"在程序开发中不可避免的要和session打交道，那么我们如何在Spring项目使用session呢？本文记录了在项目中使用session的流程和遇到的问题。 环境：SpringMVC，tomcat，redis，Spring session 配置spring session 安装jar包 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt; 安装redis，安装方式请自行google。下面附几条常用的命令。 启动redis-server.exe redis.windows.conf 运行redis-cli.exe -h 127.0.0.1 -p 6379 设置密码config set requirepass test123 授权auth test123 查询keys * 配置spring 创建spring配置 123456789@Configuration@EnableRedisHttpSession public class HttpSessionConfig &#123; // 设置HttpSession策略。默认读取header中的X-Auth-Token,作为sessionId。 @Bean public HttpSessionStrategy httpSessionStrategy() &#123; return new HeaderHttpSessionStrategy(); &#125;&#125; @EnableRedisHttpSession注解创建了springSessionRepositoryFilter来实现过滤功能，将所有的session都放在了redis中。 在.properties或者.yml文件中配置redis12345spring.session.store-type=redisspring.redis.host=localhostspring.redis.password=test123spring.redis.port=6379server.session-timeout=86400 如何获取session我们可以通过一下方式通过键值对的形式储存设置session。12HttpSession session = request.getSession();session.setAttribute(key, value); 运行后，我们可以看到redis中多了一条记录。但是我们如何把这条记录取出来呢，这个问题似乎难倒了很多人。在上面配置spring时，我们加入了以下代码12345// 设置HttpSession策略。默认读取header中的X-Auth-Token,作为sessionId。@Beanpublic HttpSessionStrategy httpSessionStrategy() &#123; return new HeaderHttpSessionStrategy(); &#125; 这段代码的作用是，当我们接收到http请求时，响应头信息会有x-auth-token，当我们你发送请求时，头信息中也会有x-auth-token。回到问题，接下来如何具体实现呢，时序图如下 当我们第一次发送请求后，响应头信息中会有一项x-auth-token，再发送下一次请求时，把第一次请求的x-auth-token及对应的值放在头信息中，那么HttpSession就认为是同一个客户发送的请求，我们就可以通过getAttribute方法获取session信息了。 时序图中的长方形表示激活，代表时序图中对象执行一项操作的时期。 总结通过时序图屡一下关系 通过时序图可以知道，我们把session信息储存在过滤器中，这样session就不依赖于各个节点的服务器，直接从高性能的键值对数据库redis中获取session信息。 参考文献：1.https://docs.spring.io/spring-session/docs/current/reference/html5/guides/rest.html","tags":[{"name":"session","slug":"session","permalink":"https://chuhang123.github.io/tags/session/"}]},{"title":"JS异步编程解决方法实例","date":"2017-07-05T15:04:07.000Z","path":"2017/07/05/Solve-js-asynchronously/","text":"在js中，如果函数B需要A的返回值，由于js的异步执行，我们会得到一个undefined，本文通过代码实例记录了js异步编程的4中解决方案。 问题实例函数A比较耗时，但是函数B需要函数A的返回结果，如果按我们正常的写法，应该是这样的12345678910111213var self = this;function A (arg) &#123; setTimeout(function () &#123; self.numA = 3 * arg; console.log(\"A的值是\" + self.numA); &#125;, 500);&#125;function B () &#123; var numB = self.numA * 4; console.log(\"B的值是\" + numB);&#125;A(2);B(3); 但是执行结果确实这样的12B的值是NaNA的值是6 如果我们使用嵌套的方法，代码是横向扩展，很不美观，且不易阅读。有以下几种解决方案。 方案一：回调函数代码如下：12345678910111213var self = this;function A (arg, callback) &#123; setTimeout(function () &#123; self.numA = 3 * arg; console.log(\"A的值是\" + self.numA); callback(); &#125;, 1000);&#125;function B () &#123; var numB = self.numA * 4; console.log(\"B的值是\" + numB);&#125;A(2, B); 输出结果如下：12A的值是6B的值是24 是我们的期望结果 如果你想在函数A执行完setTimeout之后再执行函数B，那么通过回调函数是无法事项的。可以通过下面的方法实现。 方案二：Promises对象还是按照上面的顺序，函数A需要在B前面执行。Promises对象的大致意思是没执行一个异步任务就返回一个promise对象，对象有then方法，允许有回调函数，可以这样写1234567891011121314151617var self = this;function A() &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; self.numA = 3; console.log(\"A的值是\" + self.numA); resolve('Async Hello world'); &#125;, 500); &#125;);&#125;A().then(function (value) &#123; var numB = self.numA * 4; console.log(\"B的值是\" + numB); console.log(value); // =&gt; 'Async Hello world'&#125;).catch(function (error) &#123; console.log(error);&#125;); Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。在不同的js框架中使用会有所差别。 其他除了以上两种方法，我们还可以通过事件的监听、发布/订阅等方法实现异步编程，但是不同的框架实现方法可能会有所差别。但是，作为一个初学者，我们应该抱着学习的心态使用回调函数，有助于理解js。 参考文献： Javascript异步编程的4种方法 JavaScript Promise迷你书（中文版）","tags":[{"name":"asynchronously","slug":"asynchronously","permalink":"https://chuhang123.github.io/tags/asynchronously/"}]},{"title":"净水器API","date":"2017-06-29T02:30:09.000Z","path":"2017/06/29/WaterPurifier-API/","text":"净水器方提供API接口，负责处理单个净水器的请求信息。如获取充值信息，用户使用饮水机信息等。 API列表 getCurrentTime ，获取服务器当前时间 getRechargeInfo ， 获取充值信息 isRechargeOk ，是否充值成功 useInfo ，净水器使用信息 getCurrentTime获取服务器当前时间 URLhttps://api.water.mengyunzhi.com/getCurrentTime 支持格式JSON HTTP请求方式GET 请求参数无 请求示例123GET /api/getCurrentTime HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=UTF-8Host: https://api.water.mengyunzhi.com 响应结果示例12345HTTP/1.1 200 OKContent-Type: text/plain;charset=ISO-8859-1Content-Length: 10 1498891791 getRechargeInfo获取充值水量 URLhttps://api.water.mengyunzhi.com/getRechargeInfo 支持格式JSON HTTP请求方式GET 请求参数 id。类型：Long。说明：净水器编号。 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例123GET /api/getRechargeInfo?id=23213&amp;timestamp=1497457292548&amp;randomString=unzdtggyopn1fl7sx68b8olxr&amp;encryptionInfo=37cde59cfa3384c84d9bf7545be348bc880c79bd HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=UTF-8Host: https://api.water.mengyunzhi.com 响应结果示例12345HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Content-Length: 2 20 isRechargeOk是否充值成功 URLhttps://api.water.mengyunzhi.com/isRechargeOk 支持格式JSON HTTP请求方式POST 请求参数 id。类型：Long。说明：净水器编号。 shouldRecharge.。类型：int。说明：应该充值水量。 actualRecharge。类型：int。说明：实际充值水量。 请求头信息 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例12345678910111213POST /api/isRechargeOk HTTP/1.1Content-Type: application/json;charset=UTF-8Host: https://api.water.mengyunzhi.comTimestamp: 1497457292548RandomString: unzdtggyopn1fl7sx68b8olxrEncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd &#123; \"id\": 1, \"shouldRecharge\": 200, \"actualRecharge\": 200&#125; 响应结果示例1HTTP/1.1 200 OK useInfo净水器使用信息 URLhttps://api.water.mengyunzhi.com/useInfo 支持格式JSON HTTP请求方式POST 请求参数 id。类型：Long。说明：净水器编号。 usedBeforeWaterQuality。类型：int。说明：净水前水质。 usedAfterWaterQuality。类型：int。说明：净水后水质。 usedWaterQuantity。类型：int。说明：用水量。 lastInteractTime。类型：Long。说明：上次交互的时间戳。 请求头信息 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例1234567891011121314POST /api/useInfo HTTP/1.1Content-Type: application/json;charset=UTF-8Host: https://api.water.mengyunzhi.comTimestamp: 1497457292548RandomString: unzdtggyopn1fl7sx68b8olxrEncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd &#123; \"id\": \"1\", \"usedBeforeWaterQuality\": 200, \"usedAfterWaterQuality\": 2030, \"usedWaterQuantity\": 2200, \"lastInteractTime\": 1497457292548&#125; 响应结果示例1HTTP/1.1 200 OK","tags":[{"name":"API","slug":"API","permalink":"https://chuhang123.github.io/tags/API/"}]},{"title":"git常用指令","date":"2017-06-26T14:39:45.000Z","path":"2017/06/26/git-command/","text":"在日常的开发中，经常会用到一些git指令，但是有些git指令不是太常用，用的时候经常忘记，每次都要重新google。于是，就把一些时常会用到的git 指令记录下来，方便以后使用。 假设以下所有分支名为test 删除分支 删除本地分支git branch -d test 删除远程分支git branch -r -f test，git push origin :test 查看分支 查看本地分支 git branch 查看远程分支和本地分支git branch -a 查看所有远程分支git branch -r 新建分支 新建，但不切换git branch test 新建并且换git checkout -b test 将代码添加至暂存区并提交 添加当前目录的所有文件到暂存区git add .. 提交代码git commit -m &#39;commit info&#39; 合并分支 合并分支git merge test 合并后，如果有冲突，显示冲突文件git status 配置用户名密码对于私有项目，我们每次对远程仓库操作，都需要输入用户名密码。解决方法 git config credential.helper store git pull,输入用户名密码后，用户名密码将会被存储。 git pull -u改变用户名密码 其他 最近5次commitgit log -5 --pretty --oneline 切换到某节点git checkout bd26839 新建一个commit，用来撤销指定commitgit revert bd26839 撤销上一次的提交，相当于github中的undo操作git reset HEAD~ 回复上次的提交代码git revert bd26839 强制更新远程分支：git push -f 将某个文件夹下的文件切换到某分支： git checkout development Webapp/app/index.html","tags":[{"name":"git","slug":"git","permalink":"https://chuhang123.github.io/tags/git/"}]},{"title":"在SpringMVC中启用https协议","date":"2017-06-26T08:02:03.000Z","path":"2017/06/26/Enable-https-in-Spring-Boot/","text":"由于项目需求，笔者使用SpringMVC开发的后台必须使用https协议。经过一番折腾后，终于完成了这一需求。但是由于刚接触spirng，水平有限，从中走了许多弯路，本文记录了问题的解决方案，并对从中踩过坑进行反思。 获取SSL证书获取SSL证书的方式有两种 通过keytool生成在（需要java环境），打开终端输入下面的命令123456789101112131415161718keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650Enter keystore password:Re-enter new password:What is your first and last name?[Unknown]:What is the name of your organizational unit?[Unknown]:What is the name of your organization?[Unknown]:What is the name of your City or Locality?[Unknown]:What is the name of your State or Province?[Unknown]:What is the two-letter country code for this unit?[Unknown]:Is CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown correct?[no]: yes 完成后，将会在系统目录下生成 keystore.p12文件，你也可以在指定目录下生成该文件，如果在/home/administrator/下载/installpackage/key路径下生成keystore.p12文件，可使用下面的指令1keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore /home/administrator/下载/installpackage/key/keystore.p12 -validity 3650 此方法比较方便快捷，但是浏览器会提示不安全（如下图），比较适用于开发阶段。 另外一种是通过正规渠道购买。 在SpringMVC中启用https协议首先，在配置文件中引入Spring Boot依赖。Spring Boot内嵌的tomcat服务器会在http服务的8080端口启动。在application.properties文件中通过一下配置可启用https协议：1234server.port=8443server.ssl.key-store=classpath:keystore.p12 //把之前生成的证书放在src/main/resources目录下server.ssl.key-store-password=changeitserver.ssl.key-password=changeit 按照以上配置，启动应用程序，即可访问https://localhost:8443 。 将http请求重定向至http如果你也想使你的应用程序支持http服务，可以在配置文件中增加一下代码1234567891011121314151617181920212223242526@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory() &#123; @Override protected void postProcessContext(Context context) &#123; SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint(\"CONFIDENTIAL\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(\"/*\"); securityConstraint.addCollection(collection); context.addConstraint(securityConstraint); &#125; &#125;; tomcat.addAdditionalTomcatConnectors(initiateHttpConnector()); return tomcat;&#125;private Connector initiateHttpConnector() &#123; Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\"); connector.setScheme(\"http\"); connector.setPort(8080); connector.setSecure(false); connector.setRedirectPort(8443); return connector;&#125; 配置完成后，如果您访问http://localhost8080 ,浏览器将会跳转至https://localhost:8443/ 。 所犯的错误 最开始google这个问题时，看到starkoverflow中有人说使用https服务的前提条件就是配置tomcat支持https。但是之前认为每次应用程序能在tomcat服务器上启动，是因为idea自带的tomcat。后来看了一篇官方文档 ，才知道是spring boot集成了tomcat。 有时候过于追求完美，在linux、windows系统下分别配置tomcat多个版本，然后在idea中集成tomcat时windows系统一直出问题，也耽误了一些时间。也因此有了这篇博客 总结解决这个问题花费了较长时间，主要原因是平时看文档看的太少，对很多东西都不了解。解决问题的过程中很多情况是不知道把代码放在那，不清楚是否适用于本项目。解决的问题中下载了多个实例，对sping的架构有了进一步的认识。 参考文献： Enable HTTPS in Spring Boot https://spring.io/blog/2014/03/07/deploying-spring-boot-applications https://spring.io/guides/gs/securing-web/","tags":[{"name":"https","slug":"https","permalink":"https://chuhang123.github.io/tags/https/"}]},{"title":"http请求的封装与过滤","date":"2017-06-23T14:15:49.000Z","path":"2017/06/23/http请求的封装与过滤/","text":"最近做的净水器项目，前台需要对发送的请求进行统一的封装，后台需要对请求进行统一的验证。本文记录了前台进行的http请求的封装及后台进行的http请求的过滤。前台：小程序，后台：SpringMvc. 小程序对http请求进行封装在微信小程序wx.request官网 中的http请求是这样的：12345678910111213wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) 由于请求的地址及参数是改变的，所以封装后的请求至少需要地址、请求参数。封装后代码是这样的12345678910//发送http请求var http = require(\"../../utils/httpUtil.js\"); //引入封装http的文件var params = &#123; id: app.number&#125;;var api = \"WaterPurifier/\";http.GET(api, params, function(res)&#123; console.log(res.data);&#125;); 由以上代码可知，封装的http请求是在util文件夹中建立httpUtil.js文件，可以根据自己的实际需求，对参数作统一的处理，比如统一加密之类的，也可以直接对get、post方法的header信息作统一处理。总之，对http请求封装之后，不仅实现了我们的业务需求，而且也使代码更简洁了。 参考文献：微信小程序中对网络请求的封装 SpringMvc使用zuul过滤在SpringMvc中，使用zuul可以对请求进行过滤，使用请参考官方文档 由上图可知，前台请求的地址实际上是zuul过滤器的地址，然后再由zuul过滤器进行转发到后台的逻辑层。在项目上线后，我们可以吧zuul过滤器放在一个服务器中，把后台的逻辑层代码放在另外一个服务器中，从而减轻了服务器的负担。123//获取请求RequestContext ctx = RequestContext.getCurrentContext();HttpServletRequest request = ctx.getRequest(); 我们可以根据ctx对象来设置请求的状态码、请求的头信息、拦截请求等一系列操作。查找的途径是直接看RequestContext包中的方法。 我们可以根据request对象来获取请求的参数。我们可以直接浏览HttpServletRequest接口中的方法。 总结最开始对前台的请求进行加密，后台的请求进行解密时，感觉也不麻烦。但是老师让我对请求进行封装，内心是抗拒的，当时可能感觉封装请求是个麻烦的过程。但是对前台的请求进行封装后 ，发现确实方便了很多。所以在以后的项目中，如果需要对某一类东西做统一的处理，就要封装，不仅规范，而且方便。","tags":[{"name":"小程序","slug":"小程序","permalink":"https://chuhang123.github.io/tags/小程序/"}]},{"title":"时序图使用记录","date":"2017-06-23T12:43:02.000Z","path":"2017/06/23/时序图使用记录/","text":"如果我们想清楚的表示两个类的交互过程，可以通过使用时序图来表示。本文从时序图在实际项目中的应用入手，从不规范到较为规范的过程。以及对时序图的简单学习。 背景本文的实例中，主要表示净水器和服务器之间的交互过程。需要注意的是，此实例主要表示净水器和服务器之间进行http请求。净水器的有效参数：上次交互时间、创建时间、净水前水质、净水后水质、净水器编号、用水量、充值信息。 不规范的时序图 时序图的相关知识 时序图的定义：描述了对象之间传递消息的时间顺序, 用来表示用例中的行为顺序, 是强调消息时间顺序的交互图。 时序图组成 : 时序图包括四个元素 对象(Object), 生命线(Lifeline), 激活(Activation), 消息(Message); 规范后的时序图 错误之处 请求成功的表示方法为200 返回信息为虚线，且返回消息后相应的对象不再处于激活状态 一般情况下，每发送一次消息，对方会进行回复，发送方从而判断发送的消息接收方是否接收到。 逻辑错误。（本文不予描述） 参考文献：UML入门 之 交互图 – 时序图 协作图详解","tags":[{"name":"时序图","slug":"时序图","permalink":"https://chuhang123.github.io/tags/时序图/"}]},{"title":"在IDEA中部署tomcat","date":"2017-06-23T03:21:35.000Z","path":"2017/06/23/在IDEA中部署tomcat/","text":"最近要开发一个小程序的项目，必须要使用https协议，idea自带的tomcat不知道怎么配置成https协议的，就想着在idea中部署自己电脑中的tomcat。下面是在idea中部署tomcat的过程。环境：2017版的idea，tomcat8，jdk1.8。 1.file-&gt;setting-&gt;Application Servers，添加本机的tomcat,起一个名字，选则tomcat所在的路径。 2.Run-&gt;Edit Configurations,点击左上角的加号 起一个名字，然后点击右下角的apply。 3.打开Project Structure（ctrl+Alt+shift+s） 选择artifacts，然后选择红色方框中的web appliscation: Exploded. 然后点击加号，选择directory contentl，选择项目中的一个目录即可，因为我的项目中暂时没有视图层，因此暂时选择c层的目录。然后保存运行即可。 4.这时点击运行，发现会在浏览器中访问localhost,但是服务器没有响应，会出现这样的界面 依次点击run-&gt;Debug Configurations 勾选方框中的内容，tomcat就能正常的运行了。","tags":[]},{"title":"Spring-Idea-Ubuntu环境搭建","date":"2017-06-16T01:51:34.000Z","path":"2017/06/16/Spring-Idea-Ubuntu环境搭建/","text":"近几天学习springMVC，但是发现一直比较卡，就尝试在ubuntu系统下搭建springMVC环境，看看效果。首先搭建java环境，安装jdk，下载idea，安装xampp，打开xampp的mysql控制台，创建数据库，进本的环境就起来了。 增加内存、swaf空间碰到的第一个问题是开始安装ubuntu时分配的内存有点小了，想增加磁盘空间，并提高ubuntu系统的性能。 增加ubuntu磁盘空间，请参考这里 ， 增加swaf空间,不了解swaf的，请戳这里 ，执行下面的9条语句，增加2G的swaf空间。123456789sudo suswapoff -acd /host/ubuntu/disks/mv swap.disk swap.disk.bakdd if=/dev/zero of=swap.disk bs=1024 count=2097152mkswap swap.diskswapon -afree -mrm swap.disk.bak 笔者使用的wubi装的windows、ubuntu双系统，故如果相对ubuntu系统进行改动的话，请参考官方文档 ，一定是最节约时间的方法。 数据库启动xamppsudo /opt/lampp/lampp start启动mysqlsudo /opt/lampp/lampp startmysql打开sql控制台/opt/lampp/bin/mysql -u root显示数据库show databases;删除数据库drop database name; 配置环境变量 用户目录下的 .bashrc 文件gedit ~/.bashrc该文件编辑保存后，可立即在新打开的终端窗口内生效。该方式添加的变量只能当前用户使用。 系统目录下的 profile 文件sudo gedit /etc/profile 系统目录下的 environment 文件sudo gedit /etc/environment 查看内存相关信息 查看磁盘空间df -h 查看cup使用率top 查看内存free 杀死进程killall -9 name，name表示进程的名字，如killall -9 shutter 配置tomcat 启动 1sh /usr/program/tomcat8/bin/startup.sh ; tail -200f /usr/program/tomcat8/logs/catalina.out 停止 sh /usr/program/tomcat8/bin/shutdown.sh 编辑server.xml文件sudo gedit /usr/program/tomcat8/conf/server.xml 安装见极客学院 安装nodeubuntu直接安装node，默认安装4.x版本的，所以要安装新版本的node，安装犯法如下： 6.x版本的node 12curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs 8.x版本的node12curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejs 安装软件如果软件为.deb的软件包，那么就直接安装：sudo dpkg -i xxx.deb,如果出现需要安装xxx依赖，那么就运行sudo apt-get install -f，就安装相关的依赖了。 经常断网使用ubuntu的时候，发现每隔一段时间就会断一次网，感觉很不爽，解决办法如下： 执行sudo lshw -class network命令。 1234567891011121314151617181920212223242526272829303132chuhang@chuhang:~$ sudo lshw -class network[sudo] chuhang 的密码： *-network description: Ethernet interface product: RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller vendor: Realtek Semiconductor Co., Ltd. physical id: 0 bus info: pci@0000:01:00.0 logical name: enp1s0 version: 07 serial: 34:17:eb:6c:8a:d1 size: 10Mbit/s capacity: 100Mbit/s width: 64 bits clock: 33MHz capabilities: pm msi pciexpress msix vpd bus_master cap_list ethernet physical tp mii 10bt 10bt-fd 100bt 100bt-fd autonegotiation configuration: autonegotiation=on broadcast=yes driver=r8169 driverversion=2.3LK-NAPI duplex=half firmware=rtl8106e-1_0.0.1 06/29/12 latency=0 link=no multicast=yes port=MII speed=10Mbit/s resources: irq:44 ioport:4000(size=256) memory:b0b00000-b0b00fff memory:b0800000-b0803fff *-network description: Wireless interface product: Wireless 3160 vendor: Intel Corporation physical id: 0 bus info: pci@0000:02:00.0 logical name: wlp2s0 version: 83 serial: a0:88:69:a8:1f:fb width: 64 bits clock: 33MHz capabilities: pm msi pciexpress bus_master cap_list ethernet physical wireless configuration: broadcast=yes driver=iwlwifi driverversion=4.10.0-28-generic firmware=17.459231.0 ip=10.20.103.9 latency=0 link=yes multicast=yes wireless=IEEE 802.11 resources: irq:50 memory:b0a00000-b0a01fff 新建并编辑config文件，sudo vi /etc/pm/config.d/config，在文件中输入USUSPEND_MODULES=&quot;iwlwifi enp1s0&quot;,iwlwifi对应的时driver，enp1s0对应的是 logical name。 重新连接网络sudo service network-manager restart 适用于ubuntu16.04","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://chuhang123.github.io/tags/ubuntu/"},{"name":"enviroment","slug":"enviroment","permalink":"https://chuhang123.github.io/tags/enviroment/"}]},{"title":"微信小程序wx.request请求服务器配置问题","date":"2017-06-14T14:45:24.000Z","path":"2017/06/14/微信小程序wx-request请求服务器配置问题/","text":"最近开发小程序，需要前后台对接，当使用wx.request方法向后台发送http请求时，控制台报错，随后就google了一下，本文主要讲述此问题及解决方案。 问题控制台报错截图： 看到控制台报错，提示要配置域名，google了一下，确实有很多关于wx.request请求配置服务器的文章，就配置了服务器（当时并没有服务器）。 难道在开发阶段每次测试都要吧代码推送到服务器么？有这么麻烦么？于是就开始尝试通过第三方平台，以便利前后台对接的测试，如leancloud等，然而效果并不理想。 解决方案 首先，控制台虽然报错了，但是依然可以正确的发送请求，点击请求的地址即可得到请求的返回值（如果请求地址正确的话，地址可以是本地的）。在测试阶段是可以正确的发送http请求，但是项目上线后就需要配置服务器了。 端口问题。wx,request文档中说明了请求的地址不能带有端口号，笔着使用SpringMvc后台开发，端口号是8080，讲端口号改为80即可省略端口号。 在本地开发，如果想配置服务器的话，可以通过修改host文件的方法。将本地与配置的域名进行绑定。配置方法如下： 红色方框中的代码作用是，当我们访问api.water.mengyunzhi.com服务器时，实际上访问的地址是localhost。DNS的作用就是对ip地址进行解析，使其和域名相对应。而hosts文件是用来提高效率的，在进行dns请求前，系统会先检查自己的hosts文件中是否有这个地址的映射关系，如果有，则直接调用这个映射关系，如果没有再向dns服务器提出域名解析。也就是说 Hosts 的请求级别比 DNS 高。当你的 Hosts 文件里面有对应的 IP 时，它就会直接访问那个 IP，而不用通过 DNS。相应的，在小程序的后台配置这个域名即可： 实际上访问的是localhost，这样就方便了我们前后台对接。 总结在这个问题上，笔者开始的时候犯了一个严重的错误：在软件开发中，相信大多时候第三方平台都会尽力满足开发者的需求，方便我们开发测试。而不至于发送一个请求就要配置服务器这样繁琐的操作。 如有错误，欢迎指正！","tags":[{"name":"服务器","slug":"服务器","permalink":"https://chuhang123.github.io/tags/服务器/"},{"name":"小程序","slug":"小程序","permalink":"https://chuhang123.github.io/tags/小程序/"},{"name":"wx.request","slug":"wx-request","permalink":"https://chuhang123.github.io/tags/wx-request/"}]},{"title":"验证信息真伪加密算法记录","date":"2017-06-13T15:42:25.000Z","path":"2017/06/13/验证信息真伪加密算法记录/","text":"最近做的项目后台需要验证是不是我们的用户发送的请求。起初，考虑的是使用rsa算法通过公钥、私钥的方法进行加密解密，老师给我讲了另外一种比较简单的算法，却比较实用。 问题场景前台需要向后台发送http请求，参数是编号，并根据编号获取相应的信息。那么后台如何辨别这个请求是不是我们的用户发送的呢？ 方案将发送http请求的header信息中增加几个参数，增加时间戳、随机字符串、加密信息三个参数，123timestamp: timestamp, //时间戳randomString: randomString, //随机字符串encryptionInfo: encryptionInfo //加密信息 加密信息指的是讲编号、时间戳、随机字符串、特定的字符串通过不可解密的方法加密，如sha1、md5算法，如果一次不放心的多加密几次。实例如下12var encryptionString = timestamp + randomString + 'xiaoming';var encryptionInfo = app.sha1(encryptionString); 后台对接受到的参数以及我们约定好的特定的字符串，按照同样的方法加密，如果加密后生成的字符串和前台发送的加密信息（encryptionInfo）相同，那么我们就认为这个http请求是我们的用户发送的请求。","tags":[{"name":"加密","slug":"加密","permalink":"https://chuhang123.github.io/tags/加密/"},{"name":"算法","slug":"算法","permalink":"https://chuhang123.github.io/tags/算法/"}]},{"title":"mysql下hebinate使用sql关键字报错问题","date":"2017-06-06T12:04:52.000Z","path":"2017/06/06/sql关键字报错/","text":"今天建立订单实体的时，不能生成sql文件，一直报错。当时挺无语的，开始的时候一点点吧字段都注释掉，怀疑字段名太长等，最终发现是数据表名是sql关键字。环境：mysql，hebinate，springMvc。 错误信息报错信息如下12org.hibernate.tool.hbm2ddl.SchemaExport : HHH000389: Unsuccessful: drop table if exists order2017-06-06 20:16:58.422 ERROR 8020 --- [ restartedMain] org.hibernate.tool.hbm2ddl.SchemaExport : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'order' at line 1 解决方法 给实体起一个别名。 将数据表换个名字 对比之前在php的项目中使用mysql数据库建立订单表就是使用order表，但是并没有错误，所以这个报错应该主要是hebinate的原因。但是疑问的是user也是sql保留的关键字，但是使用hebinate建立user表为什么没有报错呢？所以最终还是要以运行结果为准。 总结在sql的手册中这样说到，一条通用的规则是：如果你看到任何古怪的分析错，说命令包含任何这里列出的关键字做标识符， 那么你可以先试试用双引号把那个标识符括起来，看看问题是否消失。 sql中文手册 列出了sql的关键字。","tags":[{"name":"sql","slug":"sql","permalink":"https://chuhang123.github.io/tags/sql/"},{"name":"关键字","slug":"关键字","permalink":"https://chuhang123.github.io/tags/关键字/"},{"name":"hebinate","slug":"hebinate","permalink":"https://chuhang123.github.io/tags/hebinate/"}]},{"title":"css浮动流实战","date":"2017-06-03T14:47:22.000Z","path":"2017/06/03/css浮动流代码实现及实例讲解/","text":"前两天看了一个很赞的css浮动流的教程 ，并对应教程实现了代码，但是仅限于理论的层面 ，今天有了实战的机会，本文将问题界面录制成视频，并以解决视频中的bug作为切入点，学习css浮动流。 问题界面如下： 要解决的问题随着屏幕缩放比例的改变，video中菜单位置在改变。当屏幕比例为150%，每一个菜单占一行，占据多行。当屏幕比例为65%——75%时，菜单位于顶部。而我们的目标是当屏幕缩放比例超过150%时，隐藏菜单。当屏幕缩放比例小于150%时，位置背景图片底部，保持不变。 问题还原div是块状元素，每一个盒子在页面中时独占一行的。很明显，以上三个盒子并不是独占一行，所以，这三个盒子都是浮动的。 当屏幕缩放为25%——50%和80%——125&amp;时，三个盒子是这样的div1、div2是左浮动， div3是右浮动，但是由于屏幕宽度不够，所以div3向下移动一行。div1、div2占据第一行，div3占据第二行。效果正常。 当屏幕缩放为67%——75%时右键查看元素，查看屏幕宽度，此时屏幕的宽度时1714——1929，也就是说，此时，这三个盒子的宽度之和小于屏幕的宽度，所以这三个盒子都在页面的第一行，也就使菜单浮动到了屏幕的右上角。 解决方案就是增加div2的宽度，因为每个人的屏幕大小可能不一样，因此使用百分比，使得div3向下移动一行。 当屏幕为150%以上时此时三个盒子都是右浮动，此时屏幕宽度小于857px,字体过大，笔者使用 @media 查询 ，讲菜单隐藏。当然，也可以使用bootstrap响应式导航显示菜单。 总结书写css代码时，当遇到页面布局的问题时，应当及时打开控制台，观察各个盒子之间的关系，搞清楚盒子是不是浮动的，理性的分析原因。","tags":[{"name":"浮动","slug":"浮动","permalink":"https://chuhang123.github.io/tags/浮动/"},{"name":"实战","slug":"实战","permalink":"https://chuhang123.github.io/tags/实战/"}]},{"title":"IDEA性能优化篇","date":"2017-05-27T06:33:41.000Z","path":"2017/05/27/IDEA性能优化篇/","text":"从php转到java后，IDE改用idea了，但是使用idea运行起来比较慢，在网上搜集了一下资料优化idea，并记录如下。 调整IDEA的启动JVM参数打开idea，help-&gt;Edit Custom VM options,idea会自动复制bin目录下的idea64.exe.vmoptions文件（32位的idea.exe.vmoptions），我的运行内存是8g的，作如下调整1234567-Xms1g //JVM初始分配的堆内存-Xmx4g //JVM最大允许分配的堆内存，按需分配-XX:ReservedCodeCacheSize=1024m-XX:PermSize=372M //JVM初始分配的非堆内存-XX:MaxPermSize=744M //JVM最大允许分配的非堆内存，按需分配-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50 改变jvm参数后，如果想了解内存的分布状况，勾选一下信息，可在右下角显示内存分配 官方文档给出了推荐的修改方式，参考文献2讲述了jvm内存管理机制，及参数的详细说明，参考文献3从多个方面讲述了如何分配堆内存能够最有效的提高idea的效率。 参考文献：1.https://intellij-support.jetbrains.com/hc/en-us/articles/206544869-Configuring-JVM-options-and-platform-properties2.http://www.cnblogs.com/mingforyou/archive/2012/03/03/2378143.html3.http://tomaszdziurko.com/2015/11/1-and-the-only-one-to-customize-intellij-idea-memory-settings/ 自动编译 全部勾选红色方框中的部分 ctrl + shift + alt + /快捷键 在Edit Configuration中，查看Before launch中是否有太多设置，耽误运行时间。 jrebel热部署（待破解） 参考文献：http://www.jianshu.com/p/d177316890e3","tags":[]},{"title":"hexo+Github Pages搭建个人博客详解","date":"2017-05-19T00:01:54.000Z","path":"2017/05/19/手把手hexo建站/","text":"github Pages是托管在github上的静态网页，有300M的免费空间。Hexo 是一个快速、简洁且高效的博客框架。因为hexo是静态页面，不涉及到和数据库的交互等复杂操作，所以github pages的300M空间足以使用。本文将手把手教你在github pages上使用hexo搭建静态博客。您需要一个github账号，Node.js 、git 应用程序 hexo建站 安裝hexo npm install -g hexo-cli 初始化博客hexo init &lt;folder&gt; 切換到对应的目录cd &lt;folder&gt; 检查是否有未安装的依赖npm install 配置_config.yml文件，参考官网 ，配置文件信息务必要填写正确。eg：timezone: Asia/Shanghai，如出现拼写错误将影响文章发表的日期。 在本地预览博客hexo s 发布文章hexo new &quot;My New Post&quot;，终端会显示文章生成的路径，按照对应的路径即可编辑文章。 将博客部署到github pages上 进入github官网，创建一个github仓库，命名为username.github.io。eg：chuhang123.github.io 修改_config.yml文件的部署地址，实例如下： 1234deploy: type: git repo: https://github.com/chuhang123/chuhang123.github.io.git branch : master 将本地的博客推送到服务器上hexo d -g hexo有很多主题，读者可根据自己的喜好安装自己喜欢的主题，主题一般都会有对应的教程，如笔者使用的jacman主题 ，教程 就很详尽，请读者根据自己所选择的主题自行配置。 如出现博客推送到服务器后，css样式无法显示，执行hexo clean，再次推送即可。 hexo上传图片、视频 将图片储存在本地，通过![](/images/image.jpg)访问图片，文件夹images和_posts为同一目录。将图片放在images文件夹即可。 将图片储存在七牛云。如果你的博客有大量的图片，可以将图片放在七牛云上，然后复制url，插入即可。 上传视频，建议将视频放在七牛云上，实例效果 ，实例代码 12&lt;video src='http://oligray7m.bkt.clouddn.com/1490257478069.mp4 ' type='video/mp4' controls='controls' width='100%' height='100%'&gt;&lt;/video&gt; 使用asciinema 在终端录制视频，安装及操作过程请参考这里 ，执行asciinema rec命令，开始录制终端，Ctrl-D结束录制，录制结束后会生成录制视频的网址。您也可以注册一个asclinema账号，对录制的视频进行管理。 畅言评论系统因为多说评论系统即将关闭,disqus 在国内访问受限，所以本博客转为使用畅言 。但是很多主题默认的评论系统只有duoshuo或者disqus。所以需要自行安装。登录官网，发现使用畅言必须要有备案才能使用，不过也不用担心，在网上随便找一个域名，在ICP备案查询 中查找备案号，填入即可，审核通过后（大约要几个小时），进入畅言后台-系统设置-通用设置，进行修改即可，eg： 。 将代码放在comment.ejs文件中将博客部署到服务器上，你可能发现电脑端没有畅言评论框，打开控制台，你可能会看到下面的报错提示1chuhang123.github.io/:211 Mixed Content: The page at 'https://chuhang123.github.io/2017/05/19/%E6%89%8B%E6%8A%8A%E6%89%8Bhexo%E5%BB%BA%E7%AB%99/' was loaded over HTTPS, but requested an insecure script 'http://assets.changyan.sohu.com/upload/changyan.js?conf=c245a97f00b9a8889eb374d9a544c127&amp;appid=cyt1izVGM'. This request has been blocked; the content must be served over HTTPS. 大致是说只能使用https请求，不能使用http请求，有以下两种解决方案 因为畅言支持https加密站点，直接将js代码中的http请求修改为https即可。 在head标签中加入一下代码，会将博客中http请求自动转化为https请求，但是在本地预览可能有问题,暂时还没找到解决方案12&lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"&gt;&lt;meta name=\"author\" content=\"chuhang\"&gt; 使用任意一种解决方案后，就可以愉快的使用畅言评论系统了。 将博客部署到github后，注意博客的访问速度，如果访问过慢，打开控制台，看看是有什么原因导致的，比如使用百度站内搜索，将http修改为https后，访问速度就会变慢。 markdown基本语法Markdown 是一种轻量级标记语言，非常适合写作。现将基本的markdown语法整理如下，方便未使用过markdown的读者参考 如果您发现有的效果没有实现，不防加个空格试试。eg：### 梦云智（最后一个”#”和”梦”之间加空格）。 最后通过以上步骤，一个基本的博客站点就可以搭建起来了。建议每篇博客都要有关键词，提升被搜索引擎的找到的概率。 如果对主题的样式不是特别满意，您可以在themes/themeName/layout文件夹下修改主题页面的整体布局，在themes/themeName/source/css文件夹下修改css属性，打造属于自己的style。 如有错误，欢迎指正。谢谢！","tags":[{"name":"hexo","slug":"hexo","permalink":"https://chuhang123.github.io/tags/hexo/"}]},{"title":"错题本","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/错题本/","text":"1.一些数据是有API借口的，如航班信息。有时间尝试在tour项目的航班管理中通过API获取航班信息。2.考研机试题九度 ，配色网站Color Scheme ，易用框架easyui ,3.数据库的视图的作用是查询，不能实现增删改的功能，如果多张表关联，查询信息如果比较麻烦，那么，用视图最好不过。 4.数据表冗余问题，如果个数据表中的字段有多条信息，那么，就需要再建立一张关联的表，而不要为了方便转化成json字符串，一方面产生了数据的冗余，不易管理数据，一方面不符合软件设计的基本思想。5.剑指offer","tags":[{"name":"错题","slug":"错题","permalink":"https://chuhang123.github.io/tags/错题/"}]},{"title":"Difference between GET and POST","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/Difference-between-GET-and-POST/","text":"According to the online information and the books of PHP, I have sorted out the difference between GET and POST to deepen memory and share with you. Intrinsical distincetion in them is that GET is used to query information but POST is used to update or save information. security We might see some documents sometimes display that GET is safe but disply it is not safe sometimes. But whether GET is safe or not ? GET is displayed to be safe in the documents because we can not change data by using GET. And GET is displayed to be not safe in the documents because when we use GET to submit data, data will display in url. The size of the data transfer GETurl is limited in special browser or server. For example, the length of url in IE browser is limited as 2k+35 byters. As for other browsers, url might be limited by operating system instead of browsers. So when we use GET to transefer data, the length will be limited. POSTbecause POST dose not use url to transfer data, the size of data is not limited theoretically. Actually, web server will limite the size of data of POST(Generally does not affect). So when we upload massive data, we can only use POST. Data encodingAs the GET data is displayed in the url, and url encoding is used in ASCII coding, so the data we submit must be ASCII coding. If it is not ASCII coding, we need to convert. Default formGET is the default action of form. Relationship with serverGET is used to get data from server, while POST is used to transfer data to server.","tags":[{"name":"GET","slug":"GET","permalink":"https://chuhang123.github.io/tags/GET/"},{"name":"POST","slug":"POST","permalink":"https://chuhang123.github.io/tags/POST/"}]},{"title":"Brief process of building a personal blog","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/The-brief-process-of-building-a-personal-blog/","text":"The article is a brief statement mainly about the whole process of building personal blog, which is about from building Github Pages, learning hexo, to write blogs by using markdown, achieve the feature of uploading pictures. Tools: github account, node, npm, hexo, Image Uploader, markdown, swiftype. Building Github PagesI have built my site by Github Pages, recommond document . If you only want to write blogs, the 300M space of Github Pages is enough to use. Because now the mainstream blog framework are static page, does not involve the interaction with the database, so do not need too much space. Learning HexoBuilding hexo environment needs node, npm, and the specific installation steps has been given by hexo official website . I recommend learning materials , if after deploying on server, there are not styles, you can deploy on the site again after executing hexo clean command. I used jacman theme , due to the jacman’s author has written a detail tutorial, you can complete the theme setting by fowllowing it step by step. Writting blogs by using markdownI did not know markdown before building blog, so I download a mainstream markdown tool called reMarkable . After learning basic grammer, I have sorted out common grammer in markdown. I hope it can help you. If some of the result is not what you want, you can add a space and try it again. eg: ### mengyunzhi（there is a space between the last “#”and”m”). Uploading picturesBecause you often need some pictures to explain what you want to express, the feature of uploading pictures is necessary, I used Image Uploader to upload pictures. After downloading Image Uploader, uploading a picture and copy the url of picture by using it, you can achieve the feature of uploading pictures. Searching in siteI tried to baidu’s search site and para, but I failed. And I saw swiftype by accident, you can try it in my blog. Here is a tutorial . I recommend swiftype instead baidu and google’s search site. ConclusionAbove is the process of building a whole personal blog. Before building the blog, maybe you feel that you need to be in a high level. But after you know it, you may find you can build your blog in short time even you are amateur. I believe that if reader have the determine to build your personal blog, you can be able to do as well as you want. Good luck to you! If there are mistakes, please correct me.","tags":[]},{"title":"数据结构——线性表","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/链表/","text":"选择专业时没能选上技术方向，心痛。以后应该也没有数据结构的课程了，无奈，只能自学数据结构了，不过发现了一个很好的视频教程 ，讲的类似大话数据结构，很赞。因为时间比较紧张，而数据结构的课程有90个课时，所以这次学习的目标是了解数据结构的大致思想，敲写少量的代码加以巩固 线性表 是由n个数据元素组成的有限序列。线性表分为链表 和顺序表 。 顺序表的一般表现形式为数组，顺序表的主要特点就是长度固定，不可避免的浪费一些内存。 链表的长度是不固定的，储存的空间也不是连续的，当增加或者删除元素是也不会影响全局，但是由于链表需要很多次小块的分配内存，而分配内存的操作相对比较耗时。因此，链表不像理论分析的那么美好。 为了弥补链表在内存分配上的不足，出现了静态链表。他会预先分配一个足够长的数组，之后的数据元素都会保存在里面了。静态链表一般是由两个表组成的，一个是保存数据元素的链表，一个是保存空闲节点的链表。由于数据元素都是储存在数组中，所以经常使用数组索引代替指针。由于静态链表不需要很多次的分配内存，所以静态链表的效率和顺序表的效率几乎一样。 参考 http://www.cnblogs.com/cyjb/p/Lists.html","tags":[{"name":"链表","slug":"链表","permalink":"https://chuhang123.github.io/tags/链表/"}]},{"title":"初始cookie与session","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/初始cookie与session/","text":"作为一个程序员，你可能会经常听到cookie和session这一对好兄弟，下面简单介绍一下 他们。 了解cookie当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，（如果该Cookie尚未到期）浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。 cookie分类Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。 cookie的缺陷 Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS） Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。[3] session是什么技术session采用的是在服务器端保存状态数据的方案。当较多的用户数据长时间的储存在服务器上，会增加服务器的负担，因此session中的数据信息要尽可能的少。 关于session session_id的名称可以修改么？可以通过session_name()来获取或者设置。 session_id的值可以修改么？可以通过session_id()来获取或者设置。 session文件在计算机中的保存路径可以修改么？可以通过session_save_path()来获取或者设置。windows系统上的默认值为“C:\\Windows\\Temp”。 启动session会话后怎么做？通过session_start()函数启动回话后，接下来就可以注册session变量，PHP通过预定义数组来注册session变量，并且用isset()函数或者empty（）函数判断session变量是否注册。 session和cookie的区别。 cookie机制采用的是在客户端保存的方案，也就是说cookie数据存放在用户的浏览器上，而session机制采用的是在服务器端保存的方案，即session数据存放在服务器端。 单个cookie文件的大小在客户端限制是3字节，而session文件大小在服务器段没有限制。 恶意网站可以通过暗中读取用户cookie的方式来盗取用户的隐私信息，因此，考虑到安全性，应当减少cookie的使用，转而使用session。 session将数据保存在服务器上，当访问增多时，会降低服务器的性能，因此，考虑到减轻服务器的负担，应当减少使用session，转而使用cookie。故建议在实际开发中，将重要的信息使用session保存，其他信息使用cookie保存。 总结用户访问一个服务器，服务器首先检客户端是否含有session标识（session id）。如果客户端已经创建过session，则服务器会把他检索出来使用，如果没有，服务器会为他重新创建一个相关联的session id，并返回给客户端。用户浏览器收到这个session id后，会在硬盘的指定目录下生成客户端的session文件。文件的命名格为”sess”+session_id，文件中包含的是回话的具体内容。就这样建立一个回话后，下一次http请求时，用户浏览器会将当前域名下所有的cookie发给服务器，服务器根据cookie 中的session_id来读取保存在计算机中的相应session文件，并从session文件中获取会话的内容。 如有错误，欢迎指正！","tags":[]},{"title":"angular+thinkphp上传图片","date":"2017-05-13T01:51:34.000Z","path":"2017/05/13/angular-thinkphp上传图片/","text":"最近做的项目中需要用到图片上传功能，决定使用angular+thinkphp实现图片上传功能。尝试了ng-flow、ng-file-upload，都没有达到理想的效果，最终使用angular-file-upload实现。 效果如下： 实现流程 获取图片信息 将图片移至指定的目录下 将图片的信息保存到数据库中 具体细节下载插件示例代码，插件的示例代码非常完善，图片的缩略图功能、进度展示、图片尺寸等信息示例代码中都有，并且每一个操作的返回值也都给出了，使用非常方便。将相关资源引入，上传的样式即可实现。修改路由信息，当用户点击上传按钮时，调用请求的方法，讲图片保存，并返回图片id，点击提交按钮，将图片id存入对应的模块中。 对应的时序图如下(新增和编辑)： 时序图 如有错误，欢迎指正！","tags":[{"name":"demo","slug":"demo","permalink":"https://chuhang123.github.io/tags/demo/"}]},{"title":"基于链表的C语言信息管理系统","date":"2017-05-13T01:51:34.000Z","path":"2017/05/13/基于链表的C语言信息管理系统/","text":"这两天学习了朋友推荐的C语言链表视频教程 ，有了对链表的初步认识。教程用C对单向链表的实现了基本的增删改查操作，以及将数据储存到文件中和从文件中读取的功能。 认识链表 上图为单向链表的模型，图中包含三个节点，且每个节点包含两个部分，一部分保存或者显示节点的有关信息，一部分储存下一个节点的地址。从第一个节点依次指向最后一个节点，最后一个节点指向一个空值。如果需要查找链表的节点，则需要依次遍历节点。 功能需求基于C语言链表，实现对学生表的基本增删改查操作，将学生数据保存至文件中，从文件中取出。并逐步完善系统，如在链表头和尾及指定位置增加学生信息，恢复删除学生信息等功能。 整体规划定义学生节点STUNODE，声明链表的头和尾g_pHead，g_pEnd，使用switch语句，针对不同的指令，执行不同的命令。搭建学生信息管理系统的骨架。123456789101112//学生结点typedef struct _STU&#123; char arrStuNum[10]; char arrStuName[10]; int iStuScore; struct _STU* pNext;&#125; STUNODE;//声明链表的头和尾STUNODE* g_pHead = NULL;STUNODE* g_pEnd = NULL; 删除功能以删除功能为例，具体说明。分成只有一个节点或者多个节点两种情况讨论。 只有一个节点。 1234567//只有一个节点if (g_pHead == g_pEnd) &#123; free(g_pHead); //删除节点 g_pHead = NULL; //把链表头赋值为NULL g_pEnd = NULL; //把链表尾赋值为NULL return; //完成&#125; 有多个节点。这种情况又需要讨论了，分为链表的头、尾、中间三种。 1234567891011121314151617181920212223242526272829//如果是首节点if (g_pHead == pNode) &#123; free(g_pHead); //删除节点 g_pHead = g_pHead-&gt;pNext; //指向想一个节点 return; //完成&#125;//如果是尾节点STUNODE* pTemp = g_pHead;if (g_pEnd == pNode) &#123; //找到倒数第二个节点，并将指向空 while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = NULL; g_pEnd = pTemp; //把倒数第二个链表赋值为链表尾 free(pNode); //删除节点 return; //完成&#125; //如果是中间节点if (pNode != g_pHead &amp;&amp; pNode != g_pEnd &amp;&amp; g_pHead != g_pEnd) &#123; //找出要删除的节点前一个 while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = pNode-&gt;pNext; //剔除节点 free(pNode); //删除节点 return; //完成&#125; 实现学生信息管理系统完成增删改查后，把链表的节点的属性拼接起来，然后写入制定的文件中。读取时，拆分字符串，再将学生信息存入链表中。效果如下： 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//学生结点typedef struct _STU&#123; char arrStuNum[10]; char arrStuName[10]; int iStuScore; struct _STU* pNext;&#125; STUNODE;//声明链表的头和尾STUNODE* g_pHead = NULL;STUNODE* g_pEnd = NULL;//添加一个学生信息void AddStuMSG(char arrStuNum[10], char arrStuName[10], int iStuScore);//链表头添加一个节点void AddStuMSGToLinkHead(char arrStuNum[10], char arrStuName[10], int iStuScore);//清空链表void FreeLinkData();//打印数据void ShowStuData();//显示指令void ShowOrder();//指定位置插入节点void InsertNode(STUNODE* pTemp, char arrStuNum[10], char arrStuName[10], int iStuScore);//查找制定学生STUNODE* FindStuByNum(char* arrStuNum);//删除指定的学生void DeleteStuNode(STUNODE* pNode);//保存信息到文件中void SaveStuToFile();//读取文件中的学生信息void ReadStuFromFile();int main(void)&#123; int nOrder = -1; char arrStuNum[10] = &#123;'\\0'&#125;; char arrStuName[10] = &#123;'\\0'&#125;; int iStuScore = -1; int nFlag = 1; printf(\"***********学生信息管理系统************************\\n\"); printf(\"***********本系统操作指令如下**********************\\n\"); printf(\"*** 1、增加一个学生信息（尾添加） ***\\n\"); printf(\"*** 11、增加一个学生信息（头添加） ***\\n\"); printf(\"*** 111、增加一个学生信息（在指定位置添加） ***\\n\"); printf(\"*** 2、查找指定学生的信息（姓名/学号） ***\\n\"); printf(\"*** 3、修改指定学生的信息 ***\\n\"); printf(\"*** 4、保存业主的信息到文件中 ***\\n\"); printf(\"*** 5、读取文件的业主信息 ***\\n\"); printf(\"*** 6、删除指定学生的信息 ***\\n\"); printf(\"*** 7、恢复删除的学生的信息 ***\\n\"); printf(\"*** 9、显示所有学生的信息 ***\\n\"); printf(\"*** 0、退出系统 ***\\n\"); //读取文件中的学生信息 ReadStuFromFile(); while (nFlag) &#123; printf(\"请输入指令(10查看指令):\\n\"); //printf(\"%p\\n\", &amp;nOrder); scanf(\"%d\", &amp;nOrder); switch (nOrder) &#123; case 1: //添加一个学生信息 printf(\"输入学生的学号\\n\"); scanf(\"%s\", arrStuNum); printf(\"输入学生的姓名\\n\"); scanf(\"%s\", arrStuName); printf(\"输入学生的分数\\n\"); scanf(\"%d\", &amp;iStuScore); AddStuMSG(arrStuNum, arrStuName, iStuScore); break; case 11: //添加一个学生信息 printf(\"输入学生的学号\\n\"); scanf(\"%s\", arrStuNum); printf(\"输入学生的姓名\\n\"); scanf(\"%s\", arrStuName); printf(\"输入学生的分数\\n\"); scanf(\"%d\", &amp;iStuScore); AddStuMSGToLinkHead(arrStuNum, arrStuName, iStuScore); break; case 111: //指定位置添加学生 printf(\"输入指定学号\\n\"); scanf(\"%s\", arrStuNum); STUNODE* pTemp; pTemp = FindStuByNum(arrStuNum); if (NULL != pTemp) &#123; printf(\"输入学生的学号\\n\"); scanf(\"%s\", arrStuNum); printf(\"输入学生的姓名\\n\"); scanf(\"%s\", arrStuName); printf(\"输入学生的分数\\n\"); scanf(\"%d\", &amp;iStuScore); InsertNode(pTemp, arrStuNum, arrStuName, iStuScore); &#125; break; case 2: //查找指定学生的信息 printf(\"输入指定学号\\n\"); scanf(\"%s\", arrStuNum); pTemp = FindStuByNum(arrStuNum); //打印 if (NULL != pTemp) &#123; printf(\"学号:%s, 姓名:%s, 分数:%d\\n\", pTemp-&gt;arrStuNum, pTemp-&gt;arrStuName, pTemp-&gt;iStuScore); &#125; break; case 3: //查找指定学生的信息 printf(\"输入指定学号\\n\"); scanf(\"%s\", arrStuNum); //查找 pTemp = FindStuByNum(arrStuNum); //打印 if (NULL != pTemp) &#123; //修改学号 printf(\"请输入学号\\n\"); scanf(\"%s\", arrStuNum); strcpy(pTemp-&gt;arrStuNum, arrStuNum); //修改名字 printf(\"请输入姓名\\n\"); scanf(\"%s\", arrStuName); strcpy(pTemp-&gt;arrStuName, arrStuName); //修改分数 printf(\"请输入分数\\n\"); scanf(\"%d\", &amp;iStuScore); pTemp-&gt;iStuScore = iStuScore; &#125; break; case 4: //保存学生信息 SaveStuToFile(); break; case 6: //删除一个节点 printf(\"输入要删除的学生的学号\\n\"); scanf(\"%s\", arrStuNum); //查找 pTemp = FindStuByNum(arrStuNum); //删除一个节点 if (NULL != pTemp) &#123; DeleteStuNode(pTemp); &#125; break; case 7: //恢复 FreeLinkData(); g_pHead = NULL; g_pEnd = NULL; ReadStuFromFile(); break; case 9: ShowStuData(); break; case 10: //查看指令 ShowOrder(); break; case 0: nFlag = 0; break; default: printf(\"not right\\n\"); &#125; &#125; //保存学生信息 SaveStuToFile(); //释放链表 FreeLinkData(); return 0;&#125;//添加一个学生信息void AddStuMSG(char arrStuNum[10], char arrStuName[10], int iStuScore)&#123; //逻辑 //创建一个节点 STUNODE* pTemp = (STUNODE*)malloc (sizeof (STUNODE)); //检验参数的合法性 if (NULL == arrStuNum || NULL == arrStuName || iStuScore &lt; 0) &#123; printf(\"学生信息输入错误！\\n\"); return; &#125; //赋值 strcpy(pTemp-&gt;arrStuNum, arrStuNum); strcpy(pTemp-&gt;arrStuName, arrStuName); pTemp-&gt;iStuScore = iStuScore; pTemp-&gt;pNext = NULL; //接在链表上 if (NULL == g_pHead || NULL == g_pEnd) &#123; g_pHead = pTemp; &#125; else &#123; g_pEnd-&gt;pNext = pTemp; &#125; g_pEnd = pTemp;&#125; void FreeLinkData()&#123; STUNODE* pTemp = g_pHead; while (g_pHead != NULL) &#123; //记录结点 pTemp = g_pHead; //向后移动一个 g_pHead = g_pHead-&gt;pNext; //删除节点 free(pTemp); &#125;&#125;//打印数据void ShowStuData()&#123; STUNODE* pTemp = g_pHead; while (NULL != pTemp) &#123; printf(\"学号:%s, 姓名:%s, 分数:%d\\n\", pTemp-&gt;arrStuNum, pTemp-&gt;arrStuName, pTemp-&gt;iStuScore); //向下走一步 pTemp = pTemp-&gt;pNext; &#125;&#125;//显示指令void ShowOrder()&#123; printf(\"***********学生信息管理系统************************\\n\"); printf(\"***********本系统操作指令如下**********************\\n\"); printf(\"*** 1、增加一个学生信息（尾添加） ***\\n\"); printf(\"*** 11、增加一个学生信息（头添加） ***\\n\"); printf(\"*** 111、增加一个学生信息（在指定位置添加） ***\\n\"); printf(\"*** 2、查找指定学生的信息（姓名/学号） ***\\n\"); printf(\"*** 3、修改指定学生的信息 ***\\n\"); printf(\"*** 4、保存业主的信息到文件中 ***\\n\"); printf(\"*** 5、读取文件的业主信息 ***\\n\"); printf(\"*** 6、删除指定学生的信息 ***\\n\"); printf(\"*** 7、恢复删除的学生的信息 ***\\n\"); printf(\"*** 9、显示所有学生的信息 ***\\n\"); printf(\"*** 0、退出系统 ***\\n\");&#125;void AddStuMSGToLinkHead(char arrStuNum[10], char arrStuName[10], int iStuScore)&#123; //创建一个节点 STUNODE* pTemp = (STUNODE*)malloc(sizeof(STUNODE)); //检测参数合法性 if (NULL == arrStuNum || NULL == arrStuName || iStuScore &lt; 0) &#123; printf(\"学生信息输入错误！\\n\"); return; &#125; strcpy(pTemp-&gt;arrStuNum, arrStuNum); strcpy(pTemp-&gt;arrStuName, arrStuName); pTemp-&gt;iStuScore = iStuScore; pTemp-&gt;pNext = NULL; //链表为空 if (NULL == g_pHead || NULL == g_pEnd) &#123; g_pEnd = pTemp; &#125; else &#123; pTemp-&gt;pNext = g_pHead; &#125; g_pHead = pTemp;&#125;//查找制定学生STUNODE* FindStuByNum(char* arrStuNum)&#123; STUNODE* pTemp = g_pHead; //判断参数的合法性 if (NULL == arrStuNum) &#123; printf(\"学号输入错误！\\n\"); return NULL; &#125; //判断链表是否为空 if (NULL == g_pHead || NULL ==g_pEnd) &#123; printf(\"链表为NULL！\\n\"); return NULL; &#125; //遍历链表 while (NULL != pTemp) &#123; if (0 == strcmp(pTemp-&gt;arrStuNum, arrStuNum)) &#123; return pTemp; &#125; pTemp = pTemp-&gt;pNext; &#125; printf(\"查无此节点！\\n\"); return NULL;&#125;//指定位置插入节点void InsertNode(STUNODE* pTemp, char arrStuNum[10], char arrStuName[10], int iStuScore)&#123; //创建节点 STUNODE* pNewTemp = (STUNODE*)malloc(sizeof(STUNODE)); //成员赋值 strcpy(pNewTemp-&gt;arrStuNum, arrStuNum); strcpy(pNewTemp-&gt;arrStuName, arrStuName); pNewTemp-&gt;iStuScore = iStuScore; pNewTemp-&gt;pNext = NULL; //判断插入位置是否为未结点 if (pTemp == g_pEnd) &#123; g_pEnd-&gt;pNext = pNewTemp; g_pEnd = pNewTemp; &#125; else &#123; pNewTemp-&gt;pNext = pTemp-&gt;pNext; pTemp-&gt;pNext = pNewTemp; &#125;&#125;//删除指定的学生void DeleteStuNode(STUNODE* pNode)&#123; //只有一个节点 if (g_pHead == g_pEnd) &#123; free(g_pHead); g_pHead = NULL; g_pEnd = NULL; return; &#125; //如果是首节点 if (g_pHead == pNode) &#123; free(g_pHead); g_pHead = g_pHead-&gt;pNext; return; &#125; //如果是尾节点 STUNODE* pTemp = g_pHead; if (g_pEnd == pNode) &#123; while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = NULL; g_pEnd = pTemp; free(pNode); return; &#125; //如果是中间节点 if (pNode != g_pHead &amp;&amp; pNode != g_pEnd &amp;&amp; g_pHead != g_pEnd) &#123; while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = pNode-&gt;pNext; free(pNode); return; &#125;&#125;//保存信息到文件中void SaveStuToFile()&#123; FILE* pFile = NULL; STUNODE* pTemp = g_pHead; char strBuf[30] = &#123;0&#125;; char strScore[10] = &#123;0&#125;; //判断链表中是否为null if (g_pHead == NULL) &#123; printf(\"没有学生\\n\"); return; &#125; //打开文件 pFile = fopen(\"dat.dat\", \"wb+\"); if (NULL == pFile) &#123; printf(\"文件打开失败！\\n\"); return; &#125; //操作文件指针 while (NULL != pTemp) &#123; //学号赋值进去 strcpy(strBuf, pTemp-&gt;arrStuNum); strcat(strBuf, \".\"); //姓名 strcat(strBuf, pTemp-&gt;arrStuName); strcat(strBuf, \".\"); //分数 snprintf(strScore, 10, \"%d\", pTemp-&gt;iStuScore); //linux下不能使用itoa函数，故用此代替 //拼接字符串 strcat(strBuf, strScore); fwrite(strBuf, 1, strlen(strBuf), pFile); fwrite(\"\\r\\n\", 1, strlen(\"\\r\\n\"), pFile); pTemp = pTemp-&gt;pNext; &#125; //关闭文件 fclose(pFile);&#125;//读取文件中的学生信息void ReadStuFromFile()&#123; FILE* pFile = fopen(\"dat.dat\", \"rb+\"); char strBuf[30] = &#123;0&#125;; char strStuNum[10] = &#123;0&#125;; char strStuName[10] = &#123;0&#125;; char strStuScore[10] = &#123;0&#125;; int nCount = 0; int iStuScore; if (NULL == pFile) &#123; printf(\"文件打开失败\\n\"); return; &#125; //操作指针读取函数 while (NULL != fgets(strBuf, 30, pFile)) &#123; int i = 0; int j = 0; int nCount = 0; for (i = 0; strBuf[i] != '\\r'; i++) &#123; //没到. if (0 == nCount) &#123; strStuNum[i] = strBuf[i]; if ('.' == strBuf[i]) &#123; strStuNum[i] = '\\0'; nCount++; &#125; &#125; else if (1 == nCount) &#123; if ('.' != strBuf[i]) &#123; strStuName[j] = strBuf[i]; j++; &#125; if ('.' == strBuf[i]) &#123; strStuName[j] = '\\0'; nCount++; j = 0; &#125; &#125; else &#123; strStuScore[j] = strBuf[i]; j++; &#125; &#125; //将学生的分数转化为int类型 iStuScore = strtol(strStuScore, NULL, 10); AddStuMSG(strStuNum, strStuName, iStuScore); &#125; fclose(pFile);&#125;","tags":[{"name":"demo","slug":"demo","permalink":"https://chuhang123.github.io/tags/demo/"},{"name":"链表","slug":"链表","permalink":"https://chuhang123.github.io/tags/链表/"}]},{"title":"订单号生成规则简述","date":"2017-05-13T01:51:34.000Z","path":"2017/05/13/订单号生成规则简述/","text":"最近做的项目需要生成订单编号，查阅资料后进行了学习总结，并将最终项目中使用的订单号生成规则进行记录。 订单编号生成规则 不重复。这是生成订单号最基本、最重要的原则。比如一个人在京东上买了一个手机，另外一个人在京东上买了一包卫生纸，生成了一样的订单编号，一个人给客服打电话，客服一查，到底是哪个商品呢？ 安全。订单编号不能暴露客户的id，或者让竞争对手很容易看出近期的订单量。 不能大规模生成随机码。当订单量比较多的时候，大规模生成随机码容易发生碰撞。 控制位数。客户向客服上报订单编号时，太长不仅容易出错，而且耽误时间。 符合实际需求。订单的生成规则要根据自己的项目中实际的需求。比如一个小型网站使用淘宝的订单编号生成规则，显然有点大费周章了。 订单号尽量保持整形。提高数据库的检索效率，也不至于凌乱，或是让一些英文发信不标准的朋友尴尬。 实例参考 小米订单生成规则。1——111218—03234—5170，将订单分为四个部分。第一部分，1表示购买，2表示退货。第二部分，表示2011年12月18日下的单。第三部分，时间戳对应0:53:54。最后一部分，表示在同一秒内下的第5170单，也就是说，小米认为，在一秒内不会超过一万个订单。 宅妈妈app订单生成规则。订单是一个四位数的自增数字，可能想让用户感觉到订单在不断的增加，或者业务初期不想让用户反馈问题时报上冗长的订单号。 所犯的错开始的时候欲使用的订单生成规则为：年月日+时间戳（五为）+随机数（2位）+客户id后四位，如20170421—34324——32—32321。如果这样设置的话当客户超过十万人时，如果id为1和100001同一秒下单订单号就有可能重复，而且随机数的一般作用为混淆别人找出订单生成规则，而实际项目中没有必要，不是很符合实际需求。 项目中使用的订单生成规则综合以上因素，项目中决定使用：年月日+时间戳（后五位）+同一秒内订单生成序列号（三位）。例：20170421—34234—001，前13位精确到秒，后三位表示同一秒内生成的第一单。如果同一秒内生成了多个订单，则这些订单钱13位一样，后三位依次递增，也就是系统认为一秒内不会同时生成1000个订单。 如有错误，欢迎指正！","tags":[{"name":"web","slug":"web","permalink":"https://chuhang123.github.io/tags/web/"}]},{"title":"16-17跟媳妇平凡的日子","date":"2017-04-30T01:55:08.000Z","path":"2017/04/30/16-17跟媳妇平凡的日子/","text":"16-17和媳妇平凡的日子。 图片 **","tags":[]},{"title":"16-17美图集","date":"2017-04-30T01:54:34.000Z","path":"2017/04/30/16-17美图集/","text":"16-17和媳妇儿的美图 美图","tags":[]},{"title":"跟媳妇儿去秦皇岛","date":"2017-04-29T13:00:47.000Z","path":"2017/04/29/秦皇岛/","text":"16年十一假期的秦皇岛之旅，跟媳妇儿玩的很开心。 这是一个gallery测试","tags":[]},{"title":"Gallery","date":"2017-04-16T01:51:34.000Z","path":"2017/04/16/test/","text":"这是一个gallery测试","tags":[]},{"title":"搭建个人博客全过程简要","date":"2017-04-16T01:51:34.000Z","path":"2017/04/16/搭建个人博客简要/","text":"本文主要简述搭建个人博客的全部流程，从搭建个人站点、学习hexo，到使用markdown写博客、实现上传图片的功能，对具体的技术细节不做讲述。工具：github账号、node、npm、hexo、极简图床、markdown、swiftype。 搭建个人站点笔者通过github Pages搭建自己的站点，推荐学习资料 ，如果仅仅是用来写博客，github Pages的300M空间以足够使用，因为现在主流的博客框架均为静态界面，不涉及到和数据库的交互,故不需要太大的空间。 学习hexo搭建hexo环境需要node、npm，具体的安装步骤hexo官网 已给出，推荐hexo学习资料 ，如果部署到站点后网页无样式，执行hexo clean命令后，再次部署到站点即可。笔者使用jacman主题，由于jacman作者的教程 较为详细，只需一步一步的操作，即可完成主题的设置。 使用markdown写博客笔者在搭建博客之前从未接触过markdown，故首先下载了一个主流的markdown工具reMarkable ,了解了markdown的基本语法后，整理了常用的markdown语法，希望对您有所帮助 如果您发现有的效果没有实现，不防加个空格试试。eg：### 梦云智（最后一个”#”和”梦”之间加空格）。 上传图片因为写博客时经常需要图片加以说明，因此需要上传图片的功能，笔者使用的极简图床 上传图片，下载后，上传图片，并复制图片地址，就实现了图片的上传功能。 站内搜索折腾了百度站内搜索，没折腾出理想的效果，尝试了para，没有成功，最后无意中看到了swiftype ,效果可以再我的博客中尝试一下，推荐教程 。相比于百度、Google的站内搜索，极力推荐swiftype。 总结以上即为搭建个人博客的从无到有的过程。在搭建博客之前，可能会感觉需要过高的技术需求，但真正接触后，发现即使是一个技术小白，也完全有可能在较短的时间内搭建起自己的博客。相信读者只要有搭建博客的决心，就一定能如你所愿。Good Luck! 如有错误，欢迎指正！","tags":[{"name":"hexo","slug":"hexo","permalink":"https://chuhang123.github.io/tags/hexo/"}]}]