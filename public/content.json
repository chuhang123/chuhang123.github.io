[{"title":"https初步学习之——原理、性能","date":"2017-07-16T01:51:34.000Z","path":"2017/07/16/http-and-https/","text":"一直听说https比http安全，https 是加过密的http。但是https具体是怎样加SSL/TLS协议运行机制的概述 密认证的？http和https的安全性区别在哪里？https对服务器性能有什么影响？带着这些疑问查阅了相关资料，并记录。 http和https的区别不使用SSL/TLS的通信，就是我们所说的http通信，有以下三种风险： 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 当我们对http通信使用SSL/TLS协议后，就是我们所说的https通信，希望达到： 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 https通信过程时序图如下 说明： 步骤1中的证书包含了公钥、颁证机构、网址、过期时间。 如果服务器端需要客户端提供证书，则会在步骤1中的返回信息中增加一个参数（要求客户端提供证书），那么步骤4中也会增加一个参数（客户端证书）。 客户端和服务器端生成对称密钥后，之后所有的通信都使用对称秘钥加密。 结合实例当一个人（小明）登录一个网站后，该网站的服务器会为小明分配一个sessionId，发送给客户端，当小明再次请求这个服务器时，携带着上次分配的sessionId，这样服务器就知道是小明访问的网站了。 假设这个请求是http请求。那么，第三方就可以获取这个请求的信息，获取sessionId。然后携带着这个sessionId模拟http请求，那么服务器就会认为是小明发送的请求，第三方就可以获取、修改小明的数据等。 假设这个请求是https请求。同样的，第三方获取到了请求的相关信息，但是并不知道这里面的内容是什么，因为这些数据都是经过加密的。如果别人修改了数据，服务器也会知道这个数据被别人修改了，因为SSL/TLS协议对数据通过hash算法（如sha1、md5）加密，加密结果不一致，就会被认为内容被篡改过了。通过上面两个实例，你会不会认为使用https就一定安全呢？如果是，那你就错了。https只能保证内容在传输的过程中不会被别人篡改或者窃取。但是，如果数据在客户端或者服务器端被窃取或者修改，也一样存在风险。 http和https对服务器性能的影响网站实现https，国外比较普及，但是在国内很多网站并没有使用https，其中一个比较重要的原因是网站的用户体验和性能下降明。那么使用https对网站的性能到底有多大的影响呢？ http使用TCP 三次握手建立连接，客户端和服务器需要交换3个包，https除了 TCP 的三个包，还要加上 ssl握手需要的9个包，所以一共是12个包。一个链接测试，http是114毫秒；https建立连接，耗费436毫秒。ssl 部分花费322毫秒。你可能会问，每一次请求都需要那么多时间么？答案是否定的，第一次进行https通信时握手阶段生成的对称秘钥后，接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。在HTTP与HTTPS性能 文章中，提出了具体的优化方案，期待将来有机会在项目实战中使用到。 参考文献： HTTP 必死：先知 Google 唿吁大家升级 HTTPS， 网页浏览更有保障 http 和 https 有何区别？如何灵活使用？ 扒一扒HTTPS网站的内幕 SSL/TLS协议运行机制的概述 https时序图","tags":[{"name":"https","slug":"https","permalink":"http://127.0.0.1:8080/tags/https/"},{"name":"安全","slug":"安全","permalink":"http://127.0.0.1:8080/tags/安全/"},{"name":"服务器","slug":"服务器","permalink":"http://127.0.0.1:8080/tags/服务器/"},{"name":"性能","slug":"性能","permalink":"http://127.0.0.1:8080/tags/性能/"}]},{"title":"SpringMVC实现session分布式管理","date":"2017-07-05T19:48:23.000Z","path":"2017/07/06/Using-session-in-SpringMVC/","text":"在程序开发中不可避免的要和session打交道，那么我们如何在Spring项目使用session呢？本文记录了在项目中使用session的流程和遇到的问题。 环境：SpringMVC，tomcat，redis，Spring session 配置spring session 安装jar包 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt; 安装redis，安装方式请自行google。下面附几条常用的命令。 启动redis-server.exe redis.windows.conf 运行redis-cli.exe -h 127.0.0.1 -p 6379 设置密码config set requirepass test123 授权auth test123 查询keys * 配置spring 创建spring配置 123456789@Configuration@EnableRedisHttpSession public class HttpSessionConfig &#123; // 设置HttpSession策略。默认读取header中的X-Auth-Token,作为sessionId。 @Bean public HttpSessionStrategy httpSessionStrategy() &#123; return new HeaderHttpSessionStrategy(); &#125;&#125; @EnableRedisHttpSession注解创建了springSessionRepositoryFilter来实现过滤功能，将所有的session都放在了redis中。 在.properties或者.yml文件中配置redis12345spring.session.store-type=redisspring.redis.host=localhostspring.redis.password=test123spring.redis.port=6379server.session-timeout=86400 如何获取session我们可以通过一下方式通过键值对的形式储存设置session。12HttpSession session = request.getSession();session.setAttribute(key, value); 运行后，我们可以看到redis中多了一条记录。但是我们如何把这条记录取出来呢，这个问题似乎难倒了很多人。在上面配置spring时，我们加入了以下代码12345// 设置HttpSession策略。默认读取header中的X-Auth-Token,作为sessionId。@Beanpublic HttpSessionStrategy httpSessionStrategy() &#123; return new HeaderHttpSessionStrategy(); &#125; 这段代码的作用是，当我们接收到http请求时，响应头信息会有x-auth-token，当我们你发送请求时，头信息中也会有x-auth-token。回到问题，接下来如何具体实现呢，时序图如下 当我们第一次发送请求后，响应头信息中会有一项x-auth-token，再发送下一次请求时，把第一次请求的x-auth-token及对应的值放在头信息中，那么HttpSession就认为是同一个客户发送的请求，我们就可以通过getAttribute方法获取session信息了。 时序图中的长方形表示激活，代表时序图中对象执行一项操作的时期。 总结通过时序图屡一下关系 通过时序图可以知道，我们把session信息储存在过滤器中，这样session就不依赖于各个节点的服务器，直接从高性能的键值对数据库redis中获取session信息。 参考文献：1.https://docs.spring.io/spring-session/docs/current/reference/html5/guides/rest.html","tags":[{"name":"session","slug":"session","permalink":"http://127.0.0.1:8080/tags/session/"}]},{"title":"JS异步编程解决方法实例","date":"2017-07-05T15:04:07.000Z","path":"2017/07/05/Solve-js-asynchronously/","text":"在js中，如果函数B需要A的返回值，由于js的异步执行，我们会得到一个undefined，本文通过代码实例记录了js异步编程的4中解决方案。 问题实例函数A比较耗时，但是函数B需要函数A的返回结果，如果按我们正常的写法，应该是这样的12345678910111213var self = this;function A (arg) &#123; setTimeout(function () &#123; self.numA = 3 * arg; console.log(\"A的值是\" + self.numA); &#125;, 500);&#125;function B () &#123; var numB = self.numA * 4; console.log(\"B的值是\" + numB);&#125;A(2);B(3); 但是执行结果确实这样的12B的值是NaNA的值是6 如果我们使用嵌套的方法，代码是横向扩展，很不美观，且不易阅读。有以下几种解决方案。 方案一：回调函数代码如下：12345678910111213var self = this;function A (arg, callback) &#123; setTimeout(function () &#123; self.numA = 3 * arg; console.log(\"A的值是\" + self.numA); callback(); &#125;, 1000);&#125;function B () &#123; var numB = self.numA * 4; console.log(\"B的值是\" + numB);&#125;A(2, B); 输出结果如下：12A的值是6B的值是24 是我们的期望结果 如果你想在函数A执行完setTimeout之后再执行函数B，那么通过回调函数是无法事项的。可以通过下面的方法实现。 方案二：Promises对象还是按照上面的顺序，函数A需要在B前面执行。Promises对象的大致意思是没执行一个异步任务就返回一个promise对象，对象有then方法，允许有回调函数，可以这样写1234567891011121314151617var self = this;function A() &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; self.numA = 3; console.log(\"A的值是\" + self.numA); resolve('Async Hello world'); &#125;, 500); &#125;);&#125;A().then(function (value) &#123; var numB = self.numA * 4; console.log(\"B的值是\" + numB); console.log(value); // =&gt; 'Async Hello world'&#125;).catch(function (error) &#123; console.log(error);&#125;); Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。在不同的js框架中使用会有所差别。 其他除了以上两种方法，我们还可以通过事件的监听、发布/订阅等方法实现异步编程，但是不同的框架实现方法可能会有所差别。但是，作为一个初学者，我们应该抱着学习的心态使用回调函数，有助于理解js。 参考文献： Javascript异步编程的4种方法 JavaScript Promise迷你书（中文版）","tags":[{"name":"asynchronously","slug":"asynchronously","permalink":"http://127.0.0.1:8080/tags/asynchronously/"}]},{"title":"净水器API","date":"2017-06-29T02:30:09.000Z","path":"2017/06/29/WaterPurifier-API/","text":"净水器方提供API接口，负责处理单个净水器的请求信息。如获取充值信息，用户使用饮水机信息等。 API列表 getCurrentTime ，获取服务器当前时间 getRechargeInfo ， 获取充值信息 isRechargeOk ，是否充值成功 useInfo ，净水器使用信息 getCurrentTime获取服务器当前时间 URLhttps://api.water.mengyunzhi.com/getCurrentTime 支持格式JSON HTTP请求方式GET 请求参数无 请求示例123GET /api/getCurrentTime HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=UTF-8Host: https://api.water.mengyunzhi.com 响应结果示例12345HTTP/1.1 200 OKContent-Type: text/plain;charset=ISO-8859-1Content-Length: 10 1498891791 getRechargeInfo获取充值水量 URLhttps://api.water.mengyunzhi.com/getRechargeInfo 支持格式JSON HTTP请求方式GET 请求参数 id。类型：Long。说明：净水器编号。 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例123GET /api/getRechargeInfo?id=23213&amp;timestamp=1497457292548&amp;randomString=unzdtggyopn1fl7sx68b8olxr&amp;encryptionInfo=37cde59cfa3384c84d9bf7545be348bc880c79bd HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=UTF-8Host: https://api.water.mengyunzhi.com 响应结果示例12345HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Content-Length: 2 20 isRechargeOk是否充值成功 URLhttps://api.water.mengyunzhi.com/isRechargeOk 支持格式JSON HTTP请求方式POST 请求参数 id。类型：Long。说明：净水器编号。 shouldRecharge.。类型：int。说明：应该充值水量。 actualRecharge。类型：int。说明：实际充值水量。 请求头信息 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例12345678910111213POST /api/isRechargeOk HTTP/1.1Content-Type: application/json;charset=UTF-8Host: https://api.water.mengyunzhi.comTimestamp: 1497457292548RandomString: unzdtggyopn1fl7sx68b8olxrEncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd &#123; \"id\": 1, \"shouldRecharge\": 200, \"actualRecharge\": 200&#125; 响应结果示例1HTTP/1.1 200 OK useInfo净水器使用信息 URLhttps://api.water.mengyunzhi.com/useInfo 支持格式JSON HTTP请求方式POST 请求参数 id。类型：Long。说明：净水器编号。 usedBeforeWaterQuality。类型：int。说明：净水前水质。 usedAfterWaterQuality。类型：int。说明：净水后水质。 usedWaterQuantity。类型：int。说明：用水量。 lastInteractTime。类型：Long。说明：上次交互的时间戳。 请求头信息 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例1234567891011121314POST /api/useInfo HTTP/1.1Content-Type: application/json;charset=UTF-8Host: https://api.water.mengyunzhi.comTimestamp: 1497457292548RandomString: unzdtggyopn1fl7sx68b8olxrEncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd &#123; \"id\": \"1\", \"usedBeforeWaterQuality\": 200, \"usedAfterWaterQuality\": 2030, \"usedWaterQuantity\": 2200, \"lastInteractTime\": 1497457292548&#125; 响应结果示例1HTTP/1.1 200 OK","tags":[{"name":"API","slug":"API","permalink":"http://127.0.0.1:8080/tags/API/"}]},{"title":"git常用指令","date":"2017-06-26T14:39:45.000Z","path":"2017/06/26/git-command/","text":"在日常的开发中，经常会用到一些git指令，但是有些git指令不是太常用，用的时候经常忘记，每次都要重新google。于是，就把一些时常会用到的git 指令记录下来，方便以后使用。 假设以下所有分支名为test 删除分支 删除本地分支git branch -d test 删除远程分支git branch -r -f test，git push origin :test 查看分支 查看本地分支 git branch 查看远程分支和本地分支git branch -a 查看所有远程分支git branch -r 新建分支 新建，但不切换git branch test 新建并且换git checkout -b test 将代码添加至暂存区并提交 添加当前目录的所有文件到暂存区git add .. 提交代码git commit -m &#39;commit info&#39; 合并分支 合并分支git merge test 合并后，如果有冲突，显示冲突文件git status 其他 最近5次commitgit log -5 --pretty --oneline 切换到某节点git checkout bd26839 新建一个commit，用来撤销指定commitgit revert bd26839 撤销上一次的提交，相当于github中的undo操作git reset HEAD~ 回复上次的提交代码git revert bd26839","tags":[{"name":"git","slug":"git","permalink":"http://127.0.0.1:8080/tags/git/"}]},{"title":"在SpringMVC中启用https协议","date":"2017-06-26T08:02:03.000Z","path":"2017/06/26/Enable-https-in-Spring-Boot/","text":"由于项目需求，笔者使用SpringMVC开发的后台必须使用https协议。经过一番折腾后，终于完成了这一需求。但是由于刚接触spirng，水平有限，从中走了许多弯路，本文记录了问题的解决方案，并对从中踩过坑进行反思。 获取SSL证书获取SSL证书的方式有两种 通过keytool生成在（需要java环境），打开终端输入下面的命令123456789101112131415161718keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650Enter keystore password:Re-enter new password:What is your first and last name?[Unknown]:What is the name of your organizational unit?[Unknown]:What is the name of your organization?[Unknown]:What is the name of your City or Locality?[Unknown]:What is the name of your State or Province?[Unknown]:What is the two-letter country code for this unit?[Unknown]:Is CN=Unknown, OU=Unknown, O=Unknown, L=Unknown, ST=Unknown, C=Unknown correct?[no]: yes 完成后，将会在系统目录下生成 keystore.p12文件，你也可以在指定目录下生成该文件，如果在/home/administrator/下载/installpackage/key路径下生成keystore.p12文件，可使用下面的指令1keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore /home/administrator/下载/installpackage/key/keystore.p12 -validity 3650 此方法比较方便快捷，但是浏览器会提示不安全（如下图），比较适用于开发阶段。 另外一种是通过正规渠道购买。 在SpringMVC中启用https协议首先，在配置文件中引入Spring Boot依赖。Spring Boot内嵌的tomcat服务器会在http服务的8080端口启动。在application.properties文件中通过一下配置可启用https协议：1234server.port=8443server.ssl.key-store=classpath:keystore.p12 //把之前生成的证书放在src/main/resources目录下server.ssl.key-store-password=changeitserver.ssl.key-password=changeit 按照以上配置，启动应用程序，即可访问https://localhost:8443 。 将http请求重定向至http如果你也想使你的应用程序支持http服务，可以在配置文件中增加一下代码1234567891011121314151617181920212223242526@Beanpublic EmbeddedServletContainerFactory servletContainer() &#123; TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory() &#123; @Override protected void postProcessContext(Context context) &#123; SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint(\"CONFIDENTIAL\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(\"/*\"); securityConstraint.addCollection(collection); context.addConstraint(securityConstraint); &#125; &#125;; tomcat.addAdditionalTomcatConnectors(initiateHttpConnector()); return tomcat;&#125;private Connector initiateHttpConnector() &#123; Connector connector = new Connector(\"org.apache.coyote.http11.Http11NioProtocol\"); connector.setScheme(\"http\"); connector.setPort(8080); connector.setSecure(false); connector.setRedirectPort(8443); return connector;&#125; 配置完成后，如果您访问http://localhost8080 ,浏览器将会跳转至https://localhost:8443/ 。 所犯的错误 最开始google这个问题时，看到starkoverflow中有人说使用https服务的前提条件就是配置tomcat支持https。但是之前认为每次应用程序能在tomcat服务器上启动，是因为idea自带的tomcat。后来看了一篇官方文档 ，才知道是spring boot集成了tomcat。 有时候过于追求完美，在linux、windows系统下分别配置tomcat多个版本，然后在idea中集成tomcat时windows系统一直出问题，也耽误了一些时间。也因此有了这篇博客 总结解决这个问题花费了较长时间，主要原因是平时看文档看的太少，对很多东西都不了解。解决问题的过程中很多情况是不知道把代码放在那，不清楚是否适用于本项目。解决的问题中下载了多个实例，对sping的架构有了进一步的认识。 参考文献： Enable HTTPS in Spring Boot https://spring.io/blog/2014/03/07/deploying-spring-boot-applications https://spring.io/guides/gs/securing-web/","tags":[{"name":"https","slug":"https","permalink":"http://127.0.0.1:8080/tags/https/"}]},{"title":"http请求的封装与过滤","date":"2017-06-23T14:15:49.000Z","path":"2017/06/23/http请求的封装与过滤/","text":"最近做的净水器项目，前台需要对发送的请求进行统一的封装，后台需要对请求进行统一的验证。本文记录了前台进行的http请求的封装及后台进行的http请求的过滤。前台：小程序，后台：SpringMvc. 小程序对http请求进行封装在微信小程序wx.request官网 中的http请求是这样的：12345678910111213wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) 由于请求的地址及参数是改变的，所以封装后的请求至少需要地址、请求参数。封装后代码是这样的12345678910//发送http请求var http = require(\"../../utils/httpUtil.js\"); //引入封装http的文件var params = &#123; id: app.number&#125;;var api = \"WaterPurifier/\";http.GET(api, params, function(res)&#123; console.log(res.data);&#125;); 由以上代码可知，封装的http请求是在util文件夹中建立httpUtil.js文件，可以根据自己的实际需求，对参数作统一的处理，比如统一加密之类的，也可以直接对get、post方法的header信息作统一处理。总之，对http请求封装之后，不仅实现了我们的业务需求，而且也使代码更简洁了。 参考文献：微信小程序中对网络请求的封装 SpringMvc使用zuul过滤在SpringMvc中，使用zuul可以对请求进行过滤，使用请参考官方文档 由上图可知，前台请求的地址实际上是zuul过滤器的地址，然后再由zuul过滤器进行转发到后台的逻辑层。在项目上线后，我们可以吧zuul过滤器放在一个服务器中，把后台的逻辑层代码放在另外一个服务器中，从而减轻了服务器的负担。123//获取请求RequestContext ctx = RequestContext.getCurrentContext();HttpServletRequest request = ctx.getRequest(); 我们可以根据ctx对象来设置请求的状态码、请求的头信息、拦截请求等一系列操作。查找的途径是直接看RequestContext包中的方法。 我们可以根据request对象来获取请求的参数。我们可以直接浏览HttpServletRequest接口中的方法。 总结最开始对前台的请求进行加密，后台的请求进行解密时，感觉也不麻烦。但是老师让我对请求进行封装，内心是抗拒的，当时可能感觉封装请求是个麻烦的过程。但是对前台的请求进行封装后 ，发现确实方便了很多。所以在以后的项目中，如果需要对某一类东西做统一的处理，就要封装，不仅规范，而且方便。","tags":[{"name":"小程序","slug":"小程序","permalink":"http://127.0.0.1:8080/tags/小程序/"}]},{"title":"时序图使用记录","date":"2017-06-23T12:43:02.000Z","path":"2017/06/23/时序图使用记录/","text":"如果我们想清楚的表示两个类的交互过程，可以通过使用时序图来表示。本文从时序图在实际项目中的应用入手，从不规范到较为规范的过程。以及对时序图的简单学习。 背景本文的实例中，主要表示净水器和服务器之间的交互过程。需要注意的是，此实例主要表示净水器和服务器之间进行http请求。净水器的有效参数：上次交互时间、创建时间、净水前水质、净水后水质、净水器编号、用水量、充值信息。 不规范的时序图 时序图的相关知识 时序图的定义：描述了对象之间传递消息的时间顺序, 用来表示用例中的行为顺序, 是强调消息时间顺序的交互图。 时序图组成 : 时序图包括四个元素 对象(Object), 生命线(Lifeline), 激活(Activation), 消息(Message); 规范后的时序图 错误之处 请求成功的表示方法为200 返回信息为虚线，且返回消息后相应的对象不再处于激活状态 一般情况下，每发送一次消息，对方会进行回复，发送方从而判断发送的消息接收方是否接收到。 逻辑错误。（本文不予描述） 参考文献：UML入门 之 交互图 – 时序图 协作图详解","tags":[{"name":"时序图","slug":"时序图","permalink":"http://127.0.0.1:8080/tags/时序图/"}]},{"title":"在IDEA中部署tomcat","date":"2017-06-23T03:21:35.000Z","path":"2017/06/23/在IDEA中部署tomcat/","text":"最近要开发一个小程序的项目，必须要使用https协议，idea自带的tomcat不知道怎么配置成https协议的，就想着在idea中部署自己电脑中的tomcat。下面是在idea中部署tomcat的过程。环境：2017版的idea，tomcat8，jdk1.8。 1.file-&gt;setting-&gt;Application Servers，添加本机的tomcat,起一个名字，选则tomcat所在的路径。 2.Run-&gt;Edit Configurations,点击左上角的加号 起一个名字，然后点击右下角的apply。 3.打开Project Structure（ctrl+Alt+shift+s） 选择artifacts，然后选择红色方框中的web appliscation: Exploded. 然后点击加号，选择directory contentl，选择项目中的一个目录即可，因为我的项目中暂时没有视图层，因此暂时选择c层的目录。然后保存运行即可。 4.这时点击运行，发现会在浏览器中访问localhost,但是服务器没有响应，会出现这样的界面 依次点击run-&gt;Debug Configurations 勾选方框中的内容，tomcat就能正常的运行了。","tags":[]},{"title":"Spring-Idea-Ubuntu环境搭建","date":"2017-06-16T01:51:34.000Z","path":"2017/06/16/Spring-Idea-Ubuntu环境搭建/","text":"近几天学习springMVC，但是发现一直比较卡，就尝试在ubuntu系统下搭建springMVC环境，看看效果。首先搭建java环境，安装jdk，下载idea，安装xampp，打开xampp的mysql控制台，创建数据库，进本的环境就起来了。 增加内存、swaf空间碰到的第一个问题是开始安装ubuntu时分配的内存有点小了，想增加磁盘空间，并提高ubuntu系统的性能。 增加ubuntu磁盘空间，请参考这里 ， 增加swaf空间,不了解swaf的，请戳这里 ，执行下面的9条语句，增加2G的swaf空间。123456789sudo suswapoff -acd /host/ubuntu/disks/mv swap.disk swap.disk.bakdd if=/dev/zero of=swap.disk bs=1024 count=2097152mkswap swap.diskswapon -afree -mrm swap.disk.bak 笔者使用的wubi装的windows、ubuntu双系统，故如果相对ubuntu系统进行改动的话，请参考官方文档 ，一定是最节约时间的方法。 数据库启动xamppsudo /opt/lampp/lampp start启动mysqlsudo /opt/lampp/lampp startmysql打开sql控制台/opt/lampp/bin/mysql -u root显示数据库show databases;删除数据库drop database name; 配置环境变量 用户目录下的 .bashrc 文件gedit ~/.bashrc该文件编辑保存后，可立即在新打开的终端窗口内生效。该方式添加的变量只能当前用户使用。 系统目录下的 profile 文件sudo gedit /etc/profile 系统目录下的 environment 文件sudo gedit /etc/environment 查看内存相关信息 查看磁盘空间df -h 查看cup使用率top 查看内存free 杀死进程killall -9 name，name表示进程的名字，如killall -9 shutter 配置tomcat 启动 1sh /usr/program/tomcat8/bin/startup.sh ; tail -200f /usr/program/tomcat8/logs/catalina.out 停止 sh /usr/program/tomcat8/bin/shutdown.sh 编辑server.xml文件sudo gedit /usr/program/tomcat8/conf/server.xml 安装见极客学院","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://127.0.0.1:8080/tags/ubuntu/"},{"name":"enviroment","slug":"enviroment","permalink":"http://127.0.0.1:8080/tags/enviroment/"}]},{"title":"微信小程序wx.request请求服务器配置问题","date":"2017-06-14T14:45:24.000Z","path":"2017/06/14/微信小程序wx-request请求服务器配置问题/","text":"最近开发小程序，需要前后台对接，当使用wx.request方法向后台发送http请求时，控制台报错，随后就google了一下，本文主要讲述此问题及解决方案。 问题控制台报错截图： 看到控制台报错，提示要配置域名，google了一下，确实有很多关于wx.request请求配置服务器的文章，就配置了服务器（当时并没有服务器）。 难道在开发阶段每次测试都要吧代码推送到服务器么？有这么麻烦么？于是就开始尝试通过第三方平台，以便利前后台对接的测试，如leancloud等，然而效果并不理想。 解决方案 首先，控制台虽然报错了，但是依然可以正确的发送请求，点击请求的地址即可得到请求的返回值（如果请求地址正确的话，地址可以是本地的）。在测试阶段是可以正确的发送http请求，但是项目上线后就需要配置服务器了。 端口问题。wx,request文档中说明了请求的地址不能带有端口号，笔着使用SpringMvc后台开发，端口号是8080，讲端口号改为80即可省略端口号。 在本地开发，如果想配置服务器的话，可以通过修改host文件的方法。将本地与配置的域名进行绑定。配置方法如下： 红色方框中的代码作用是，当我们访问api.water.mengyunzhi.com服务器时，实际上访问的地址是localhost。DNS的作用就是对ip地址进行解析，使其和域名相对应。而hosts文件是用来提高效率的，在进行dns请求前，系统会先检查自己的hosts文件中是否有这个地址的映射关系，如果有，则直接调用这个映射关系，如果没有再向dns服务器提出域名解析。也就是说 Hosts 的请求级别比 DNS 高。当你的 Hosts 文件里面有对应的 IP 时，它就会直接访问那个 IP，而不用通过 DNS。相应的，在小程序的后台配置这个域名即可： 实际上访问的是localhost，这样就方便了我们前后台对接。 总结在这个问题上，笔者开始的时候犯了一个严重的错误：在软件开发中，相信大多时候第三方平台都会尽力满足开发者的需求，方便我们开发测试。而不至于发送一个请求就要配置服务器这样繁琐的操作。 如有错误，欢迎指正！","tags":[{"name":"服务器","slug":"服务器","permalink":"http://127.0.0.1:8080/tags/服务器/"},{"name":"小程序","slug":"小程序","permalink":"http://127.0.0.1:8080/tags/小程序/"},{"name":"wx.request","slug":"wx-request","permalink":"http://127.0.0.1:8080/tags/wx-request/"}]},{"title":"验证信息真伪加密算法记录","date":"2017-06-13T15:42:25.000Z","path":"2017/06/13/验证信息真伪加密算法记录/","text":"最近做的项目后台需要验证是不是我们的用户发送的请求。起初，考虑的是使用rsa算法通过公钥、私钥的方法进行加密解密，老师给我讲了另外一种比较简单的算法，却比较实用。 问题场景前台需要向后台发送http请求，参数是编号，并根据编号获取相应的信息。那么后台如何辨别这个请求是不是我们的用户发送的呢？ 方案将发送http请求的header信息中增加几个参数，增加时间戳、随机字符串、加密信息三个参数，123timestamp: timestamp, //时间戳randomString: randomString, //随机字符串encryptionInfo: encryptionInfo //加密信息 加密信息指的是讲编号、时间戳、随机字符串、特定的字符串通过不可解密的方法加密，如sha1、md5算法，如果一次不放心的多加密几次。实例如下12var encryptionString = timestamp + randomString + 'xiaoming';var encryptionInfo = app.sha1(encryptionString); 后台对接受到的参数以及我们约定好的特定的字符串，按照同样的方法加密，如果加密后生成的字符串和前台发送的加密信息（encryptionInfo）相同，那么我们就认为这个http请求是我们的用户发送的请求。","tags":[{"name":"加密","slug":"加密","permalink":"http://127.0.0.1:8080/tags/加密/"},{"name":"算法","slug":"算法","permalink":"http://127.0.0.1:8080/tags/算法/"}]},{"title":"mysql下hebinate使用sql关键字报错问题","date":"2017-06-06T12:04:52.000Z","path":"2017/06/06/sql关键字报错/","text":"今天建立订单实体的时，不能生成sql文件，一直报错。当时挺无语的，开始的时候一点点吧字段都注释掉，怀疑字段名太长等，最终发现是数据表名是sql关键字。环境：mysql，hebinate，springMvc。 错误信息报错信息如下12org.hibernate.tool.hbm2ddl.SchemaExport : HHH000389: Unsuccessful: drop table if exists order2017-06-06 20:16:58.422 ERROR 8020 --- [ restartedMain] org.hibernate.tool.hbm2ddl.SchemaExport : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'order' at line 1 解决方法 给实体起一个别名。 将数据表换个名字 对比之前在php的项目中使用mysql数据库建立订单表就是使用order表，但是并没有错误，所以这个报错应该主要是hebinate的原因。但是疑问的是user也是sql保留的关键字，但是使用hebinate建立user表为什么没有报错呢？所以最终还是要以运行结果为准。 总结在sql的手册中这样说到，一条通用的规则是：如果你看到任何古怪的分析错，说命令包含任何这里列出的关键字做标识符， 那么你可以先试试用双引号把那个标识符括起来，看看问题是否消失。 sql中文手册 列出了sql的关键字。","tags":[{"name":"sql","slug":"sql","permalink":"http://127.0.0.1:8080/tags/sql/"},{"name":"关键字","slug":"关键字","permalink":"http://127.0.0.1:8080/tags/关键字/"},{"name":"hebinate","slug":"hebinate","permalink":"http://127.0.0.1:8080/tags/hebinate/"}]},{"title":"css浮动流实战","date":"2017-06-03T14:47:22.000Z","path":"2017/06/03/css浮动流代码实现及实例讲解/","text":"前两天看了一个很赞的css浮动流的教程 ，并对应教程实现了代码，但是仅限于理论的层面 ，今天有了实战的机会，本文将问题界面录制成视频，并以解决视频中的bug作为切入点，学习css浮动流。 问题界面如下： 要解决的问题随着屏幕缩放比例的改变，video中菜单位置在改变。当屏幕比例为150%，每一个菜单占一行，占据多行。当屏幕比例为65%——75%时，菜单位于顶部。而我们的目标是当屏幕缩放比例超过150%时，隐藏菜单。当屏幕缩放比例小于150%时，位置背景图片底部，保持不变。 问题还原div是块状元素，每一个盒子在页面中时独占一行的。很明显，以上三个盒子并不是独占一行，所以，这三个盒子都是浮动的。 当屏幕缩放为25%——50%和80%——125&amp;时，三个盒子是这样的div1、div2是左浮动， div3是右浮动，但是由于屏幕宽度不够，所以div3向下移动一行。div1、div2占据第一行，div3占据第二行。效果正常。 当屏幕缩放为67%——75%时右键查看元素，查看屏幕宽度，此时屏幕的宽度时1714——1929，也就是说，此时，这三个盒子的宽度之和小于屏幕的宽度，所以这三个盒子都在页面的第一行，也就使菜单浮动到了屏幕的右上角。 解决方案就是增加div2的宽度，因为每个人的屏幕大小可能不一样，因此使用百分比，使得div3向下移动一行。 当屏幕为150%以上时此时三个盒子都是右浮动，此时屏幕宽度小于857px,字体过大，笔者使用 @media 查询 ，讲菜单隐藏。当然，也可以使用bootstrap响应式导航显示菜单。 总结书写css代码时，当遇到页面布局的问题时，应当及时打开控制台，观察各个盒子之间的关系，搞清楚盒子是不是浮动的，理性的分析原因。","tags":[{"name":"浮动","slug":"浮动","permalink":"http://127.0.0.1:8080/tags/浮动/"},{"name":"实战","slug":"实战","permalink":"http://127.0.0.1:8080/tags/实战/"}]},{"title":"IDEA性能优化篇","date":"2017-05-27T06:33:41.000Z","path":"2017/05/27/IDEA性能优化篇/","text":"从php转到java后，IDE改用idea了，但是使用idea运行起来比较慢，在网上搜集了一下资料优化idea，并记录如下。 调整IDEA的启动JVM参数打开idea，help-&gt;Edit Custom VM options,idea会自动复制bin目录下的idea64.exe.vmoptions文件（32位的idea.exe.vmoptions），我的运行内存是8g的，作如下调整1234567-Xms1g //JVM初始分配的堆内存-Xmx4g //JVM最大允许分配的堆内存，按需分配-XX:ReservedCodeCacheSize=1024m-XX:PermSize=372M //JVM初始分配的非堆内存-XX:MaxPermSize=744M //JVM最大允许分配的非堆内存，按需分配-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50 改变jvm参数后，如果想了解内存的分布状况，勾选一下信息，可在右下角显示内存分配 官方文档给出了推荐的修改方式，参考文献2讲述了jvm内存管理机制，及参数的详细说明，参考文献3从多个方面讲述了如何分配堆内存能够最有效的提高idea的效率。 参考文献：1.https://intellij-support.jetbrains.com/hc/en-us/articles/206544869-Configuring-JVM-options-and-platform-properties2.http://www.cnblogs.com/mingforyou/archive/2012/03/03/2378143.html3.http://tomaszdziurko.com/2015/11/1-and-the-only-one-to-customize-intellij-idea-memory-settings/ 自动编译全部勾选红色方框中的部分 在Edit Configuration中，查看Before launch中是否有太多设置，耽误运行时间。 jrebel热部署（待破解） 参考文献：http://www.jianshu.com/p/d177316890e3","tags":[]},{"title":"hexo+Github Pages搭建个人博客详解","date":"2017-05-19T00:01:54.000Z","path":"2017/05/19/手把手hexo建站/","text":"github Pages是托管在github上的静态网页，有300M的免费空间。Hexo 是一个快速、简洁且高效的博客框架。因为hexo是静态页面，不涉及到和数据库的交互等复杂操作，所以github pages的300M空间足以使用。本文将手把手教你在github pages上使用hexo搭建静态博客。您需要一个github账号，Node.js 、git 应用程序 hexo建站 安裝hexo npm install -g hexo-cli 初始化博客hexo init &lt;folder&gt; 切換到对应的目录cd &lt;folder&gt; 检查是否有未安装的依赖npm install 配置_config.yml文件，参考官网 ，配置文件信息务必要填写正确。eg：timezone: Asia/Shanghai，如出现拼写错误将影响文章发表的日期。 在本地预览博客hexo s 发布文章hexo new &quot;My New Post&quot;，终端会显示文章生成的路径，按照对应的路径即可编辑文章。 将博客部署到github pages上 进入github官网，创建一个github仓库，命名为username.github.io。eg：chuhang123.github.io 修改_config.yml文件的部署地址，实例如下： 1234deploy: type: git repo: https://github.com/chuhang123/chuhang123.github.io.git branch : master 将本地的博客推送到服务器上hexo d -g hexo有很多主题，读者可根据自己的喜好安装自己喜欢的主题，主题一般都会有对应的教程，如笔者使用的jacman主题 ，教程 就很详尽，请读者根据自己所选择的主题自行配置。 如出现博客推送到服务器后，css样式无法显示，执行hexo clean，再次推送即可。 hexo上传图片、视频 将图片储存在本地，通过![](/images/image.jpg)访问图片，文件夹images和_posts为同一目录。将图片放在images文件夹即可。 将图片储存在七牛云。如果你的博客有大量的图片，可以将图片放在七牛云上，然后复制url，插入即可。 上传视频，建议将视频放在七牛云上，实例效果 ，实例代码 12&lt;video src='http://oligray7m.bkt.clouddn.com/1490257478069.mp4 ' type='video/mp4' controls='controls' width='100%' height='100%'&gt;&lt;/video&gt; 使用asciinema 在终端录制视频，安装及操作过程请参考这里 ，执行asciinema rec命令，开始录制终端，Ctrl-D结束录制，录制结束后会生成录制视频的网址。您也可以注册一个asclinema账号，对录制的视频进行管理。 畅言评论系统因为多说评论系统即将关闭,disqus 在国内访问受限，所以本博客转为使用畅言 。但是很多主题默认的评论系统只有duoshuo或者disqus。所以需要自行安装。登录官网，发现使用畅言必须要有备案才能使用，不过也不用担心，在网上随便找一个域名，在ICP备案查询 中查找备案号，填入即可，审核通过后（大约要几个小时），进入畅言后台-系统设置-通用设置，进行修改即可，eg： 。 将代码放在comment.ejs文件中将博客部署到服务器上，你可能发现电脑端没有畅言评论框，打开控制台，你可能会看到下面的报错提示1chuhang123.github.io/:211 Mixed Content: The page at 'https://chuhang123.github.io/2017/05/19/%E6%89%8B%E6%8A%8A%E6%89%8Bhexo%E5%BB%BA%E7%AB%99/' was loaded over HTTPS, but requested an insecure script 'http://assets.changyan.sohu.com/upload/changyan.js?conf=c245a97f00b9a8889eb374d9a544c127&amp;appid=cyt1izVGM'. This request has been blocked; the content must be served over HTTPS. 大致是说只能使用https请求，不能使用http请求，有以下两种解决方案 因为畅言支持https加密站点，直接将js代码中的http请求修改为https即可。 在head标签中加入一下代码，会将博客中http请求自动转化为https请求，但是在本地预览可能有问题,暂时还没找到解决方案12&lt;meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"&gt;&lt;meta name=\"author\" content=\"chuhang\"&gt; 使用任意一种解决方案后，就可以愉快的使用畅言评论系统了。 将博客部署到github后，注意博客的访问速度，如果访问过慢，打开控制台，看看是有什么原因导致的，比如使用百度站内搜索，将http修改为https后，访问速度就会变慢。 markdown基本语法Markdown 是一种轻量级标记语言，非常适合写作。现将基本的markdown语法整理如下，方便未使用过markdown的读者参考 如果您发现有的效果没有实现，不防加个空格试试。eg：### 梦云智（最后一个”#”和”梦”之间加空格）。 最后通过以上步骤，一个基本的博客站点就可以搭建起来了。建议每篇博客都要有关键词，提升被搜索引擎的找到的概率。 如果对主题的样式不是特别满意，您可以在themes/themeName/layout文件夹下修改主题页面的整体布局，在themes/themeName/source/css文件夹下修改css属性，打造属于自己的style。 如有错误，欢迎指正。谢谢！","tags":[{"name":"hexo","slug":"hexo","permalink":"http://127.0.0.1:8080/tags/hexo/"}]},{"title":"初始cookie与session","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/初始cookie与session/","text":"作为一个程序员，你可能会经常听到cookie和session这一对好兄弟，下面简单介绍一下 他们。 了解cookie当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，（如果该Cookie尚未到期）浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。 cookie分类Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie。内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。 cookie的缺陷 Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。 由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS） Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。[3] session是什么技术session采用的是在服务器端保存状态数据的方案。当较多的用户数据长时间的储存在服务器上，会增加服务器的负担，因此session中的数据信息要尽可能的少。 关于session session_id的名称可以修改么？可以通过session_name()来获取或者设置。 session_id的值可以修改么？可以通过session_id()来获取或者设置。 session文件在计算机中的保存路径可以修改么？可以通过session_save_path()来获取或者设置。windows系统上的默认值为“C:\\Windows\\Temp”。 启动session会话后怎么做？通过session_start()函数启动回话后，接下来就可以注册session变量，PHP通过预定义数组来注册session变量，并且用isset()函数或者empty（）函数判断session变量是否注册。 session和cookie的区别。 cookie机制采用的是在客户端保存的方案，也就是说cookie数据存放在用户的浏览器上，而session机制采用的是在服务器端保存的方案，即session数据存放在服务器端。 单个cookie文件的大小在客户端限制是3字节，而session文件大小在服务器段没有限制。 恶意网站可以通过暗中读取用户cookie的方式来盗取用户的隐私信息，因此，考虑到安全性，应当减少cookie的使用，转而使用session。 session将数据保存在服务器上，当访问增多时，会降低服务器的性能，因此，考虑到减轻服务器的负担，应当减少使用session，转而使用cookie。故建议在实际开发中，将重要的信息使用session保存，其他信息使用cookie保存。 总结用户访问一个服务器，服务器首先检客户端是否含有session标识（session id）。如果客户端已经创建过session，则服务器会把他检索出来使用，如果没有，服务器会为他重新创建一个相关联的session id，并返回给客户端。用户浏览器收到这个session id后，会在硬盘的指定目录下生成客户端的session文件。文件的命名格为”sess”+session_id，文件中包含的是回话的具体内容。就这样建立一个回话后，下一次http请求时，用户浏览器会将当前域名下所有的cookie发给服务器，服务器根据cookie 中的session_id来读取保存在计算机中的相应session文件，并从session文件中获取会话的内容。 如有错误，欢迎指正！","tags":[]},{"title":"Brief process of building a personal blog","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/The-brief-process-of-building-a-personal-blog/","text":"The article is a brief statement mainly about the whole process of building personal blog, which is about from building Github Pages, learning hexo, to write blogs by using markdown, achieve the feature of uploading pictures. Tools: github account, node, npm, hexo, Image Uploader, markdown, swiftype. Building Github PagesI have built my site by Github Pages, recommond document . If you only want to write blogs, the 300M space of Github Pages is enough to use. Because now the mainstream blog framework are static page, does not involve the interaction with the database, so do not need too much space. Learning HexoBuilding hexo environment needs node, npm, and the specific installation steps has been given by hexo official website . I recommend learning materials , if after deploying on server, there are not styles, you can deploy on the site again after executing hexo clean command. I used jacman theme , due to the jacman’s author has written a detail tutorial, you can complete the theme setting by fowllowing it step by step. Writting blogs by using markdownI did not know markdown before building blog, so I download a mainstream markdown tool called reMarkable . After learning basic grammer, I have sorted out common grammer in markdown. I hope it can help you. If some of the result is not what you want, you can add a space and try it again. eg: ### mengyunzhi（there is a space between the last “#”and”m”). Uploading picturesBecause you often need some pictures to explain what you want to express, the feature of uploading pictures is necessary, I used Image Uploader to upload pictures. After downloading Image Uploader, uploading a picture and copy the url of picture by using it, you can achieve the feature of uploading pictures. Searching in siteI tried to baidu’s search site and para, but I failed. And I saw swiftype by accident, you can try it in my blog. Here is a tutorial . I recommend swiftype instead baidu and google’s search site. ConclusionAbove is the process of building a whole personal blog. Before building the blog, maybe you feel that you need to be in a high level. But after you know it, you may find you can build your blog in short time even you are amateur. I believe that if reader have the determine to build your personal blog, you can be able to do as well as you want. Good luck to you! If there are mistakes, please correct me.","tags":[]},{"title":"错题本","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/错题本/","text":"1.一些数据是有API借口的，如航班信息。有时间尝试在tour项目的航班管理中通过API获取航班信息。2.考研机试题九度 ，配色网站Color Scheme ，易用框架easyui ,3.数据库的视图的作用是查询，不能实现增删改的功能，如果多张表关联，查询信息如果比较麻烦，那么，用视图最好不过。 4.数据表冗余问题，如果个数据表中的字段有多条信息，那么，就需要再建立一张关联的表，而不要为了方便转化成json字符串，一方面产生了数据的冗余，不易管理数据，一方面不符合软件设计的基本思想。5.剑指offer","tags":[{"name":"错题","slug":"错题","permalink":"http://127.0.0.1:8080/tags/错题/"}]},{"title":"Difference between GET and POST","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/Difference-between-GET-and-POST/","text":"According to the online information and the books of PHP, I have sorted out the difference between GET and POST to deepen memory and share with you. Intrinsical distincetion in them is that GET is used to query information but POST is used to update or save information. security We might see some documents sometimes display that GET is safe but disply it is not safe sometimes. But whether GET is safe or not ? GET is displayed to be safe in the documents because we can not change data by using GET. And GET is displayed to be not safe in the documents because when we use GET to submit data, data will display in url. The size of the data transfer GETurl is limited in special browser or server. For example, the length of url in IE browser is limited as 2k+35 byters. As for other browsers, url might be limited by operating system instead of browsers. So when we use GET to transefer data, the length will be limited. POSTbecause POST dose not use url to transfer data, the size of data is not limited theoretically. Actually, web server will limite the size of data of POST(Generally does not affect). So when we upload massive data, we can only use POST. Data encodingAs the GET data is displayed in the url, and url encoding is used in ASCII coding, so the data we submit must be ASCII coding. If it is not ASCII coding, we need to convert. Default formGET is the default action of form. Relationship with serverGET is used to get data from server, while POST is used to transfer data to server.","tags":[{"name":"GET","slug":"GET","permalink":"http://127.0.0.1:8080/tags/GET/"},{"name":"POST","slug":"POST","permalink":"http://127.0.0.1:8080/tags/POST/"}]},{"title":"数据结构——线性表","date":"2017-05-16T01:51:34.000Z","path":"2017/05/16/链表/","text":"选择专业时没能选上技术方向，心痛。以后应该也没有数据结构的课程了，无奈，只能自学数据结构了，不过发现了一个很好的视频教程 ，讲的类似大话数据结构，很赞。因为时间比较紧张，而数据结构的课程有90个课时，所以这次学习的目标是了解数据结构的大致思想，敲写少量的代码加以巩固 线性表 是由n个数据元素组成的有限序列。线性表分为链表 和顺序表 。 顺序表的一般表现形式为数组，顺序表的主要特点就是长度固定，不可避免的浪费一些内存。 链表的长度是不固定的，储存的空间也不是连续的，当增加或者删除元素是也不会影响全局，但是由于链表需要很多次小块的分配内存，而分配内存的操作相对比较耗时。因此，链表不像理论分析的那么美好。 为了弥补链表在内存分配上的不足，出现了静态链表。他会预先分配一个足够长的数组，之后的数据元素都会保存在里面了。静态链表一般是由两个表组成的，一个是保存数据元素的链表，一个是保存空闲节点的链表。由于数据元素都是储存在数组中，所以经常使用数组索引代替指针。由于静态链表不需要很多次的分配内存，所以静态链表的效率和顺序表的效率几乎一样。 参考 http://www.cnblogs.com/cyjb/p/Lists.html","tags":[{"name":"链表","slug":"链表","permalink":"http://127.0.0.1:8080/tags/链表/"}]},{"title":"基于链表的C语言信息管理系统","date":"2017-05-13T01:51:34.000Z","path":"2017/05/13/基于链表的C语言信息管理系统/","text":"这两天学习了朋友推荐的C语言链表视频教程 ，有了对链表的初步认识。教程用C对单向链表的实现了基本的增删改查操作，以及将数据储存到文件中和从文件中读取的功能。 认识链表 上图为单向链表的模型，图中包含三个节点，且每个节点包含两个部分，一部分保存或者显示节点的有关信息，一部分储存下一个节点的地址。从第一个节点依次指向最后一个节点，最后一个节点指向一个空值。如果需要查找链表的节点，则需要依次遍历节点。 功能需求基于C语言链表，实现对学生表的基本增删改查操作，将学生数据保存至文件中，从文件中取出。并逐步完善系统，如在链表头和尾及指定位置增加学生信息，恢复删除学生信息等功能。 整体规划定义学生节点STUNODE，声明链表的头和尾g_pHead，g_pEnd，使用switch语句，针对不同的指令，执行不同的命令。搭建学生信息管理系统的骨架。123456789101112//学生结点typedef struct _STU&#123; char arrStuNum[10]; char arrStuName[10]; int iStuScore; struct _STU* pNext;&#125; STUNODE;//声明链表的头和尾STUNODE* g_pHead = NULL;STUNODE* g_pEnd = NULL; 删除功能以删除功能为例，具体说明。分成只有一个节点或者多个节点两种情况讨论。 只有一个节点。 1234567//只有一个节点if (g_pHead == g_pEnd) &#123; free(g_pHead); //删除节点 g_pHead = NULL; //把链表头赋值为NULL g_pEnd = NULL; //把链表尾赋值为NULL return; //完成&#125; 有多个节点。这种情况又需要讨论了，分为链表的头、尾、中间三种。 1234567891011121314151617181920212223242526272829//如果是首节点if (g_pHead == pNode) &#123; free(g_pHead); //删除节点 g_pHead = g_pHead-&gt;pNext; //指向想一个节点 return; //完成&#125;//如果是尾节点STUNODE* pTemp = g_pHead;if (g_pEnd == pNode) &#123; //找到倒数第二个节点，并将指向空 while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = NULL; g_pEnd = pTemp; //把倒数第二个链表赋值为链表尾 free(pNode); //删除节点 return; //完成&#125; //如果是中间节点if (pNode != g_pHead &amp;&amp; pNode != g_pEnd &amp;&amp; g_pHead != g_pEnd) &#123; //找出要删除的节点前一个 while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = pNode-&gt;pNext; //剔除节点 free(pNode); //删除节点 return; //完成&#125; 实现学生信息管理系统完成增删改查后，把链表的节点的属性拼接起来，然后写入制定的文件中。读取时，拆分字符串，再将学生信息存入链表中。效果如下： 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//学生结点typedef struct _STU&#123; char arrStuNum[10]; char arrStuName[10]; int iStuScore; struct _STU* pNext;&#125; STUNODE;//声明链表的头和尾STUNODE* g_pHead = NULL;STUNODE* g_pEnd = NULL;//添加一个学生信息void AddStuMSG(char arrStuNum[10], char arrStuName[10], int iStuScore);//链表头添加一个节点void AddStuMSGToLinkHead(char arrStuNum[10], char arrStuName[10], int iStuScore);//清空链表void FreeLinkData();//打印数据void ShowStuData();//显示指令void ShowOrder();//指定位置插入节点void InsertNode(STUNODE* pTemp, char arrStuNum[10], char arrStuName[10], int iStuScore);//查找制定学生STUNODE* FindStuByNum(char* arrStuNum);//删除指定的学生void DeleteStuNode(STUNODE* pNode);//保存信息到文件中void SaveStuToFile();//读取文件中的学生信息void ReadStuFromFile();int main(void)&#123; int nOrder = -1; char arrStuNum[10] = &#123;'\\0'&#125;; char arrStuName[10] = &#123;'\\0'&#125;; int iStuScore = -1; int nFlag = 1; printf(\"***********学生信息管理系统************************\\n\"); printf(\"***********本系统操作指令如下**********************\\n\"); printf(\"*** 1、增加一个学生信息（尾添加） ***\\n\"); printf(\"*** 11、增加一个学生信息（头添加） ***\\n\"); printf(\"*** 111、增加一个学生信息（在指定位置添加） ***\\n\"); printf(\"*** 2、查找指定学生的信息（姓名/学号） ***\\n\"); printf(\"*** 3、修改指定学生的信息 ***\\n\"); printf(\"*** 4、保存业主的信息到文件中 ***\\n\"); printf(\"*** 5、读取文件的业主信息 ***\\n\"); printf(\"*** 6、删除指定学生的信息 ***\\n\"); printf(\"*** 7、恢复删除的学生的信息 ***\\n\"); printf(\"*** 9、显示所有学生的信息 ***\\n\"); printf(\"*** 0、退出系统 ***\\n\"); //读取文件中的学生信息 ReadStuFromFile(); while (nFlag) &#123; printf(\"请输入指令(10查看指令):\\n\"); //printf(\"%p\\n\", &amp;nOrder); scanf(\"%d\", &amp;nOrder); switch (nOrder) &#123; case 1: //添加一个学生信息 printf(\"输入学生的学号\\n\"); scanf(\"%s\", arrStuNum); printf(\"输入学生的姓名\\n\"); scanf(\"%s\", arrStuName); printf(\"输入学生的分数\\n\"); scanf(\"%d\", &amp;iStuScore); AddStuMSG(arrStuNum, arrStuName, iStuScore); break; case 11: //添加一个学生信息 printf(\"输入学生的学号\\n\"); scanf(\"%s\", arrStuNum); printf(\"输入学生的姓名\\n\"); scanf(\"%s\", arrStuName); printf(\"输入学生的分数\\n\"); scanf(\"%d\", &amp;iStuScore); AddStuMSGToLinkHead(arrStuNum, arrStuName, iStuScore); break; case 111: //指定位置添加学生 printf(\"输入指定学号\\n\"); scanf(\"%s\", arrStuNum); STUNODE* pTemp; pTemp = FindStuByNum(arrStuNum); if (NULL != pTemp) &#123; printf(\"输入学生的学号\\n\"); scanf(\"%s\", arrStuNum); printf(\"输入学生的姓名\\n\"); scanf(\"%s\", arrStuName); printf(\"输入学生的分数\\n\"); scanf(\"%d\", &amp;iStuScore); InsertNode(pTemp, arrStuNum, arrStuName, iStuScore); &#125; break; case 2: //查找指定学生的信息 printf(\"输入指定学号\\n\"); scanf(\"%s\", arrStuNum); pTemp = FindStuByNum(arrStuNum); //打印 if (NULL != pTemp) &#123; printf(\"学号:%s, 姓名:%s, 分数:%d\\n\", pTemp-&gt;arrStuNum, pTemp-&gt;arrStuName, pTemp-&gt;iStuScore); &#125; break; case 3: //查找指定学生的信息 printf(\"输入指定学号\\n\"); scanf(\"%s\", arrStuNum); //查找 pTemp = FindStuByNum(arrStuNum); //打印 if (NULL != pTemp) &#123; //修改学号 printf(\"请输入学号\\n\"); scanf(\"%s\", arrStuNum); strcpy(pTemp-&gt;arrStuNum, arrStuNum); //修改名字 printf(\"请输入姓名\\n\"); scanf(\"%s\", arrStuName); strcpy(pTemp-&gt;arrStuName, arrStuName); //修改分数 printf(\"请输入分数\\n\"); scanf(\"%d\", &amp;iStuScore); pTemp-&gt;iStuScore = iStuScore; &#125; break; case 4: //保存学生信息 SaveStuToFile(); break; case 6: //删除一个节点 printf(\"输入要删除的学生的学号\\n\"); scanf(\"%s\", arrStuNum); //查找 pTemp = FindStuByNum(arrStuNum); //删除一个节点 if (NULL != pTemp) &#123; DeleteStuNode(pTemp); &#125; break; case 7: //恢复 FreeLinkData(); g_pHead = NULL; g_pEnd = NULL; ReadStuFromFile(); break; case 9: ShowStuData(); break; case 10: //查看指令 ShowOrder(); break; case 0: nFlag = 0; break; default: printf(\"not right\\n\"); &#125; &#125; //保存学生信息 SaveStuToFile(); //释放链表 FreeLinkData(); return 0;&#125;//添加一个学生信息void AddStuMSG(char arrStuNum[10], char arrStuName[10], int iStuScore)&#123; //逻辑 //创建一个节点 STUNODE* pTemp = (STUNODE*)malloc (sizeof (STUNODE)); //检验参数的合法性 if (NULL == arrStuNum || NULL == arrStuName || iStuScore &lt; 0) &#123; printf(\"学生信息输入错误！\\n\"); return; &#125; //赋值 strcpy(pTemp-&gt;arrStuNum, arrStuNum); strcpy(pTemp-&gt;arrStuName, arrStuName); pTemp-&gt;iStuScore = iStuScore; pTemp-&gt;pNext = NULL; //接在链表上 if (NULL == g_pHead || NULL == g_pEnd) &#123; g_pHead = pTemp; &#125; else &#123; g_pEnd-&gt;pNext = pTemp; &#125; g_pEnd = pTemp;&#125; void FreeLinkData()&#123; STUNODE* pTemp = g_pHead; while (g_pHead != NULL) &#123; //记录结点 pTemp = g_pHead; //向后移动一个 g_pHead = g_pHead-&gt;pNext; //删除节点 free(pTemp); &#125;&#125;//打印数据void ShowStuData()&#123; STUNODE* pTemp = g_pHead; while (NULL != pTemp) &#123; printf(\"学号:%s, 姓名:%s, 分数:%d\\n\", pTemp-&gt;arrStuNum, pTemp-&gt;arrStuName, pTemp-&gt;iStuScore); //向下走一步 pTemp = pTemp-&gt;pNext; &#125;&#125;//显示指令void ShowOrder()&#123; printf(\"***********学生信息管理系统************************\\n\"); printf(\"***********本系统操作指令如下**********************\\n\"); printf(\"*** 1、增加一个学生信息（尾添加） ***\\n\"); printf(\"*** 11、增加一个学生信息（头添加） ***\\n\"); printf(\"*** 111、增加一个学生信息（在指定位置添加） ***\\n\"); printf(\"*** 2、查找指定学生的信息（姓名/学号） ***\\n\"); printf(\"*** 3、修改指定学生的信息 ***\\n\"); printf(\"*** 4、保存业主的信息到文件中 ***\\n\"); printf(\"*** 5、读取文件的业主信息 ***\\n\"); printf(\"*** 6、删除指定学生的信息 ***\\n\"); printf(\"*** 7、恢复删除的学生的信息 ***\\n\"); printf(\"*** 9、显示所有学生的信息 ***\\n\"); printf(\"*** 0、退出系统 ***\\n\");&#125;void AddStuMSGToLinkHead(char arrStuNum[10], char arrStuName[10], int iStuScore)&#123; //创建一个节点 STUNODE* pTemp = (STUNODE*)malloc(sizeof(STUNODE)); //检测参数合法性 if (NULL == arrStuNum || NULL == arrStuName || iStuScore &lt; 0) &#123; printf(\"学生信息输入错误！\\n\"); return; &#125; strcpy(pTemp-&gt;arrStuNum, arrStuNum); strcpy(pTemp-&gt;arrStuName, arrStuName); pTemp-&gt;iStuScore = iStuScore; pTemp-&gt;pNext = NULL; //链表为空 if (NULL == g_pHead || NULL == g_pEnd) &#123; g_pEnd = pTemp; &#125; else &#123; pTemp-&gt;pNext = g_pHead; &#125; g_pHead = pTemp;&#125;//查找制定学生STUNODE* FindStuByNum(char* arrStuNum)&#123; STUNODE* pTemp = g_pHead; //判断参数的合法性 if (NULL == arrStuNum) &#123; printf(\"学号输入错误！\\n\"); return NULL; &#125; //判断链表是否为空 if (NULL == g_pHead || NULL ==g_pEnd) &#123; printf(\"链表为NULL！\\n\"); return NULL; &#125; //遍历链表 while (NULL != pTemp) &#123; if (0 == strcmp(pTemp-&gt;arrStuNum, arrStuNum)) &#123; return pTemp; &#125; pTemp = pTemp-&gt;pNext; &#125; printf(\"查无此节点！\\n\"); return NULL;&#125;//指定位置插入节点void InsertNode(STUNODE* pTemp, char arrStuNum[10], char arrStuName[10], int iStuScore)&#123; //创建节点 STUNODE* pNewTemp = (STUNODE*)malloc(sizeof(STUNODE)); //成员赋值 strcpy(pNewTemp-&gt;arrStuNum, arrStuNum); strcpy(pNewTemp-&gt;arrStuName, arrStuName); pNewTemp-&gt;iStuScore = iStuScore; pNewTemp-&gt;pNext = NULL; //判断插入位置是否为未结点 if (pTemp == g_pEnd) &#123; g_pEnd-&gt;pNext = pNewTemp; g_pEnd = pNewTemp; &#125; else &#123; pNewTemp-&gt;pNext = pTemp-&gt;pNext; pTemp-&gt;pNext = pNewTemp; &#125;&#125;//删除指定的学生void DeleteStuNode(STUNODE* pNode)&#123; //只有一个节点 if (g_pHead == g_pEnd) &#123; free(g_pHead); g_pHead = NULL; g_pEnd = NULL; return; &#125; //如果是首节点 if (g_pHead == pNode) &#123; free(g_pHead); g_pHead = g_pHead-&gt;pNext; return; &#125; //如果是尾节点 STUNODE* pTemp = g_pHead; if (g_pEnd == pNode) &#123; while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = NULL; g_pEnd = pTemp; free(pNode); return; &#125; //如果是中间节点 if (pNode != g_pHead &amp;&amp; pNode != g_pEnd &amp;&amp; g_pHead != g_pEnd) &#123; while (pTemp-&gt;pNext != pNode) &#123; pTemp = pTemp-&gt;pNext; &#125; pTemp-&gt;pNext = pNode-&gt;pNext; free(pNode); return; &#125;&#125;//保存信息到文件中void SaveStuToFile()&#123; FILE* pFile = NULL; STUNODE* pTemp = g_pHead; char strBuf[30] = &#123;0&#125;; char strScore[10] = &#123;0&#125;; //判断链表中是否为null if (g_pHead == NULL) &#123; printf(\"没有学生\\n\"); return; &#125; //打开文件 pFile = fopen(\"dat.dat\", \"wb+\"); if (NULL == pFile) &#123; printf(\"文件打开失败！\\n\"); return; &#125; //操作文件指针 while (NULL != pTemp) &#123; //学号赋值进去 strcpy(strBuf, pTemp-&gt;arrStuNum); strcat(strBuf, \".\"); //姓名 strcat(strBuf, pTemp-&gt;arrStuName); strcat(strBuf, \".\"); //分数 snprintf(strScore, 10, \"%d\", pTemp-&gt;iStuScore); //linux下不能使用itoa函数，故用此代替 //拼接字符串 strcat(strBuf, strScore); fwrite(strBuf, 1, strlen(strBuf), pFile); fwrite(\"\\r\\n\", 1, strlen(\"\\r\\n\"), pFile); pTemp = pTemp-&gt;pNext; &#125; //关闭文件 fclose(pFile);&#125;//读取文件中的学生信息void ReadStuFromFile()&#123; FILE* pFile = fopen(\"dat.dat\", \"rb+\"); char strBuf[30] = &#123;0&#125;; char strStuNum[10] = &#123;0&#125;; char strStuName[10] = &#123;0&#125;; char strStuScore[10] = &#123;0&#125;; int nCount = 0; int iStuScore; if (NULL == pFile) &#123; printf(\"文件打开失败\\n\"); return; &#125; //操作指针读取函数 while (NULL != fgets(strBuf, 30, pFile)) &#123; int i = 0; int j = 0; int nCount = 0; for (i = 0; strBuf[i] != '\\r'; i++) &#123; //没到. if (0 == nCount) &#123; strStuNum[i] = strBuf[i]; if ('.' == strBuf[i]) &#123; strStuNum[i] = '\\0'; nCount++; &#125; &#125; else if (1 == nCount) &#123; if ('.' != strBuf[i]) &#123; strStuName[j] = strBuf[i]; j++; &#125; if ('.' == strBuf[i]) &#123; strStuName[j] = '\\0'; nCount++; j = 0; &#125; &#125; else &#123; strStuScore[j] = strBuf[i]; j++; &#125; &#125; //将学生的分数转化为int类型 iStuScore = strtol(strStuScore, NULL, 10); AddStuMSG(strStuNum, strStuName, iStuScore); &#125; fclose(pFile);&#125;","tags":[{"name":"demo","slug":"demo","permalink":"http://127.0.0.1:8080/tags/demo/"},{"name":"链表","slug":"链表","permalink":"http://127.0.0.1:8080/tags/链表/"}]},{"title":"angular+thinkphp上传图片","date":"2017-05-13T01:51:34.000Z","path":"2017/05/13/angular-thinkphp上传图片/","text":"最近做的项目中需要用到图片上传功能，决定使用angular+thinkphp实现图片上传功能。尝试了ng-flow、ng-file-upload，都没有达到理想的效果，最终使用angular-file-upload实现。 效果如下： 实现流程 获取图片信息 将图片移至指定的目录下 将图片的信息保存到数据库中 具体细节下载插件示例代码，插件的示例代码非常完善，图片的缩略图功能、进度展示、图片尺寸等信息示例代码中都有，并且每一个操作的返回值也都给出了，使用非常方便。将相关资源引入，上传的样式即可实现。修改路由信息，当用户点击上传按钮时，调用请求的方法，讲图片保存，并返回图片id，点击提交按钮，将图片id存入对应的模块中。 对应的时序图如下(新增和编辑)： 时序图 如有错误，欢迎指正！","tags":[{"name":"demo","slug":"demo","permalink":"http://127.0.0.1:8080/tags/demo/"}]},{"title":"订单号生成规则简述","date":"2017-05-13T01:51:34.000Z","path":"2017/05/13/订单号生成规则简述/","text":"最近做的项目需要生成订单编号，查阅资料后进行了学习总结，并将最终项目中使用的订单号生成规则进行记录。 订单编号生成规则 不重复。这是生成订单号最基本、最重要的原则。比如一个人在京东上买了一个手机，另外一个人在京东上买了一包卫生纸，生成了一样的订单编号，一个人给客服打电话，客服一查，到底是哪个商品呢？ 安全。订单编号不能暴露客户的id，或者让竞争对手很容易看出近期的订单量。 不能大规模生成随机码。当订单量比较多的时候，大规模生成随机码容易发生碰撞。 控制位数。客户向客服上报订单编号时，太长不仅容易出错，而且耽误时间。 符合实际需求。订单的生成规则要根据自己的项目中实际的需求。比如一个小型网站使用淘宝的订单编号生成规则，显然有点大费周章了。 订单号尽量保持整形。提高数据库的检索效率，也不至于凌乱，或是让一些英文发信不标准的朋友尴尬。 实例参考 小米订单生成规则。1——111218—03234—5170，将订单分为四个部分。第一部分，1表示购买，2表示退货。第二部分，表示2011年12月18日下的单。第三部分，时间戳对应0:53:54。最后一部分，表示在同一秒内下的第5170单，也就是说，小米认为，在一秒内不会超过一万个订单。 宅妈妈app订单生成规则。订单是一个四位数的自增数字，可能想让用户感觉到订单在不断的增加，或者业务初期不想让用户反馈问题时报上冗长的订单号。 所犯的错开始的时候欲使用的订单生成规则为：年月日+时间戳（五为）+随机数（2位）+客户id后四位，如20170421—34324——32—32321。如果这样设置的话当客户超过十万人时，如果id为1和100001同一秒下单订单号就有可能重复，而且随机数的一般作用为混淆别人找出订单生成规则，而实际项目中没有必要，不是很符合实际需求。 项目中使用的订单生成规则综合以上因素，项目中决定使用：年月日+时间戳（后五位）+同一秒内订单生成序列号（三位）。例：20170421—34234—001，前13位精确到秒，后三位表示同一秒内生成的第一单。如果同一秒内生成了多个订单，则这些订单钱13位一样，后三位依次递增，也就是系统认为一秒内不会同时生成1000个订单。 如有错误，欢迎指正！","tags":[{"name":"web","slug":"web","permalink":"http://127.0.0.1:8080/tags/web/"}]},{"title":"16-17跟媳妇平凡的日子","date":"2017-04-30T01:55:08.000Z","path":"2017/04/30/16-17跟媳妇平凡的日子/","text":"16-17和媳妇平凡的日子。 图片 **","tags":[]},{"title":"16-17美图集","date":"2017-04-30T01:54:34.000Z","path":"2017/04/30/16-17美图集/","text":"16-17和媳妇儿的美图 美图","tags":[]},{"title":"跟媳妇儿去秦皇岛","date":"2017-04-29T13:00:47.000Z","path":"2017/04/29/秦皇岛/","text":"16年十一假期的秦皇岛之旅，跟媳妇儿玩的很开心。 这是一个gallery测试","tags":[]},{"title":"Gallery","date":"2017-04-16T01:51:34.000Z","path":"2017/04/16/test/","text":"这是一个gallery测试","tags":[]},{"title":"搭建个人博客全过程简要","date":"2017-04-16T01:51:34.000Z","path":"2017/04/16/搭建个人博客简要/","text":"本文主要简述搭建个人博客的全部流程，从搭建个人站点、学习hexo，到使用markdown写博客、实现上传图片的功能，对具体的技术细节不做讲述。工具：github账号、node、npm、hexo、极简图床、markdown、swiftype。 搭建个人站点笔者通过github Pages搭建自己的站点，推荐学习资料 ，如果仅仅是用来写博客，github Pages的300M空间以足够使用，因为现在主流的博客框架均为静态界面，不涉及到和数据库的交互,故不需要太大的空间。 学习hexo搭建hexo环境需要node、npm，具体的安装步骤hexo官网 已给出，推荐hexo学习资料 ，如果部署到站点后网页无样式，执行hexo clean命令后，再次部署到站点即可。笔者使用jacman主题，由于jacman作者的教程 较为详细，只需一步一步的操作，即可完成主题的设置。 使用markdown写博客笔者在搭建博客之前从未接触过markdown，故首先下载了一个主流的markdown工具reMarkable ,了解了markdown的基本语法后，整理了常用的markdown语法，希望对您有所帮助 如果您发现有的效果没有实现，不防加个空格试试。eg：### 梦云智（最后一个”#”和”梦”之间加空格）。 上传图片因为写博客时经常需要图片加以说明，因此需要上传图片的功能，笔者使用的极简图床 上传图片，下载后，上传图片，并复制图片地址，就实现了图片的上传功能。 站内搜索折腾了百度站内搜索，没折腾出理想的效果，尝试了para，没有成功，最后无意中看到了swiftype ,效果可以再我的博客中尝试一下，推荐教程 。相比于百度、Google的站内搜索，极力推荐swiftype。 总结以上即为搭建个人博客的从无到有的过程。在搭建博客之前，可能会感觉需要过高的技术需求，但真正接触后，发现即使是一个技术小白，也完全有可能在较短的时间内搭建起自己的博客。相信读者只要有搭建博客的决心，就一定能如你所愿。Good Luck! 如有错误，欢迎指正！","tags":[{"name":"hexo","slug":"hexo","permalink":"http://127.0.0.1:8080/tags/hexo/"}]}]